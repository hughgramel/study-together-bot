import {
  Client,
  GatewayIntentBits,
  Partials,
  REST,
  Routes,
  SlashCommandBuilder,
  CommandInteraction,
  ModalSubmitInteraction,
  PermissionFlagsBits,
  ChannelType,
  TextChannel,
  EmbedBuilder,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  ActionRowBuilder,
  StringSelectMenuBuilder,
  StringSelectMenuInteraction,
  ButtonBuilder,
  ButtonStyle,
  ButtonInteraction,
} from 'discord.js';
import * as admin from 'firebase-admin';
import { Firestore, Timestamp } from 'firebase-admin/firestore';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import { SessionService } from './services/sessions';
import { StatsService } from './services/stats';
import { AchievementService } from './services/achievements';
import { PostService } from './services/posts';
import { DailyGoalService } from './services/dailyGoal';
import { XPService } from './services/xp';
import { EventService } from './services/events';
import { getAchievement, getAllAchievements } from './data/achievements';
import { ServerConfig } from './types';
import {
  formatDuration,
  calculateDuration,
  isSameDay,
  isYesterday,
} from './utils/formatters';
import { calculateLevel, xpToNextLevel, levelProgress, xpForLevel } from './utils/xp';

// Load environment variables
dotenv.config();

// Initialize Firebase
let serviceAccount: admin.ServiceAccount;

// Check if running in production with environment variable
if (process.env.FIREBASE_SERVICE_ACCOUNT && process.env.FIREBASE_SERVICE_ACCOUNT.trim().length > 0) {
  try {
    serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
    console.log('‚úÖ Loaded Firebase credentials from environment variable');
  } catch (error) {
    console.error('‚ùå Failed to parse FIREBASE_SERVICE_ACCOUNT environment variable:', error);
    process.exit(1);
  }
} else {
  // Local development - load from file
  const serviceAccountPath = path.join(
    __dirname,
    '../firebase-service-account.json'
  );

  if (!fs.existsSync(serviceAccountPath)) {
    console.error('‚ùå Firebase service account file not found and FIREBASE_SERVICE_ACCOUNT env var not set');
    console.error('Please set FIREBASE_SERVICE_ACCOUNT environment variable or provide firebase-service-account.json');
    process.exit(1);
  }

  serviceAccount = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));
  console.log('‚úÖ Loaded Firebase credentials from local file');
}

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  projectId: process.env.FIREBASE_PROJECT_ID,
});

const db: Firestore = admin.firestore();
const sessionService = new SessionService(db);
const statsService = new StatsService(db);
const achievementService = new AchievementService(db);
const postService = new PostService(db);
const dailyGoalService = new DailyGoalService(db);
const xpService = new XPService(db);
const eventService = new EventService(db);

// Create Discord client
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildMembers,
  ],
  partials: [
    Partials.Message,
    Partials.Channel,
    Partials.Reaction,
  ],
});

// Store auto-end timers for paused sessions (userId -> NodeJS.Timeout)
const autoEndTimers = new Map<string, NodeJS.Timeout>();

// Store event builder state (builderId -> event data)
interface EventBuilderState {
  userId: string;
  title?: string;
  location?: string;
  startTime?: Date;
  duration?: number;
  studyType?: 'silent' | 'conversation' | 'pomodoro' | 'custom';
  customType?: string;
  maxAttendees?: number;
  description?: string;
}
const eventBuilders = new Map<string, EventBuilderState>();

// Define slash commands
const commands = [
  new SlashCommandBuilder()
    .setName('ping')
    .setDescription('Test if bot is responsive'),

  new SlashCommandBuilder()
    .setName('start')
    .setDescription('Start a new productivity session')
    .addStringOption((option) =>
      option
        .setName('activity')
        .setDescription('What you are working on')
        .setRequired(true)
    ),

  new SlashCommandBuilder()
    .setName('end')
    .setDescription('End your session! Add a title, description of what you did, and post it to the feed'),

  new SlashCommandBuilder()
    .setName('pause')
    .setDescription('Pause your active session'),

  new SlashCommandBuilder()
    .setName('resume')
    .setDescription('Resume your paused session'),

  new SlashCommandBuilder()
    .setName('time')
    .setDescription('Check your current session status'),

  new SlashCommandBuilder()
    .setName('cancel')
    .setDescription('Cancel your active session without saving'),

  new SlashCommandBuilder()
    .setName('stats')
    .setDescription('View your productivity statistics')
    .addStringOption((option) =>
      option
        .setName('timeframe')
        .setDescription('Time period to view')
        .setRequired(false)
        .addChoices(
          { name: 'Today', value: 'today' },
          { name: 'This Week', value: 'week' },
          { name: 'This Month', value: 'month' },
          { name: 'All Time', value: 'all-time' }
        )
    ),

  new SlashCommandBuilder()
    .setName('achievements')
    .setDescription('View all your unlocked achievements'),

  new SlashCommandBuilder()
    .setName('profile')
    .setDescription('View a user\'s profile with all stats and achievements')
    .addUserOption(option =>
      option
        .setName('user')
        .setDescription('User to view (defaults to yourself)')
        .setRequired(false)
    ),

  new SlashCommandBuilder()
    .setName('compare')
    .setDescription('Compare your stats with another user')
    .addUserOption(option =>
      option
        .setName('user')
        .setDescription('User to compare with')
        .setRequired(true)
    ),

  new SlashCommandBuilder()
    .setName('leaderboard')
    .setDescription('View server leaderboards with timeframe selector'),

  new SlashCommandBuilder()
    .setName('live')
    .setDescription('See who is currently studying in this server'),

  new SlashCommandBuilder()
    .setName('setup-feed')
    .setDescription('Configure the feed channel for completed sessions (Admin only)')
    .addChannelOption((option) =>
      option
        .setName('channel')
        .setDescription('The channel to post completed sessions')
        .setRequired(true)
        .addChannelTypes(ChannelType.GuildText)
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  new SlashCommandBuilder()
    .setName('setup-focus-room')
    .setDescription('Configure voice channels for auto-tracking (Admin only)')
    .addChannelOption((option) =>
      option
        .setName('channel')
        .setDescription('The voice channel to enable auto-tracking')
        .setRequired(true)
        .addChannelTypes(ChannelType.GuildVoice)
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  new SlashCommandBuilder()
    .setName('set-welcome-channel')
    .setDescription('Configure the welcome channel for new members (Admin only)')
    .addChannelOption((option) =>
      option
        .setName('channel')
        .setDescription('The channel to send welcome messages')
        .setRequired(true)
        .addChannelTypes(ChannelType.GuildText)
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  new SlashCommandBuilder()
    .setName('setup-events-channel')
    .setDescription('Configure the events channel for study events (Admin only)')
    .addChannelOption((option) =>
      option
        .setName('channel')
        .setDescription('The channel to post study events')
        .setRequired(true)
        .addChannelTypes(ChannelType.GuildText)
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  new SlashCommandBuilder()
    .setName('manual')
    .setDescription('Log a manual session with custom duration'),

  new SlashCommandBuilder()
    .setName('help')
    .setDescription('View all available commands and how to use them'),

  new SlashCommandBuilder()
    .setName('goal')
    .setDescription('Manage your goals')
    .addSubcommand(subcommand =>
      subcommand
        .setName('add')
        .setDescription('Add a new goal')
        .addStringOption(option =>
          option
            .setName('goal')
            .setDescription('Your goal (e.g., "Finish homework")')
            .setRequired(true)
        )
        .addStringOption(option =>
          option
            .setName('difficulty')
            .setDescription('Goal difficulty')
            .setRequired(true)
            .addChoices(
              { name: 'Easy (50 XP)', value: 'easy' },
              { name: 'Medium (100 XP)', value: 'medium' },
              { name: 'Hard (200 XP)', value: 'hard' }
            )
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('complete')
        .setDescription('Mark a goal as complete')
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('list')
        .setDescription('View all your goals')
    ),

  new SlashCommandBuilder()
    .setName('createevent')
    .setDescription('Create a new study event'),

  new SlashCommandBuilder()
    .setName('events')
    .setDescription('View all upcoming study events'),

  new SlashCommandBuilder()
    .setName('myevents')
    .setDescription('View events you have RSVP\'d to'),

  new SlashCommandBuilder()
    .setName('cancelevent')
    .setDescription('Cancel one of your events')
    .addStringOption(option =>
      option
        .setName('event')
        .setDescription('The event to cancel')
        .setRequired(true)
    ),
].map((command) => command.toJSON());

// Register commands
async function registerCommands() {
  const rest = new REST({ version: '10' }).setToken(
    process.env.DISCORD_BOT_TOKEN!
  );

  try {
    console.log('Started refreshing application (/) commands.');

    await rest.put(Routes.applicationCommands(process.env.DISCORD_CLIENT_ID!), {
      body: commands,
    });

    console.log('Successfully reloaded application (/) commands.');
  } catch (error) {
    console.error('Error registering commands:', error);
  }
}

// Helper function to get start of day in Pacific Time
function getStartOfDayPacific(): Date {
  const now = new Date();

  // Convert current time to Pacific Time
  const pacificTimeStr = now.toLocaleString('en-US', {
    timeZone: 'America/Los_Angeles',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });

  // Parse the Pacific time string (MM/DD/YYYY, HH:mm:ss)
  const [datePart] = pacificTimeStr.split(', ');
  const [month, day, year] = datePart.split('/');

  // Create a date string for midnight Pacific Time
  // Use PST offset (-08:00) for winter, PDT (-07:00) for summer
  // JavaScript will handle the conversion automatically
  const pacificDateStr = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;

  // Determine if we're in PST or PDT by checking if DST is active
  const jan = new Date(now.getFullYear(), 0, 1);
  const jul = new Date(now.getFullYear(), 6, 1);
  const stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  const isDST = now.getTimezoneOffset() < stdTimezoneOffset;

  // Create midnight Pacific Time (use -07:00 for PDT, -08:00 for PST)
  const offset = isDST ? '-07:00' : '-08:00';
  const midnightPacific = new Date(`${pacificDateStr}T00:00:00${offset}`);

  return midnightPacific;
}

// Helper function to get start of week (Sunday) in Pacific Time
function getStartOfWeekPacific(): Date {
  const now = new Date();

  // Convert current time to Pacific Time
  const pacificTimeStr = now.toLocaleString('en-US', {
    timeZone: 'America/Los_Angeles',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });

  // Parse the Pacific time string
  const [datePart] = pacificTimeStr.split(', ');
  const [month, day, year] = datePart.split('/');

  // Create a date object for today in Pacific Time
  const pacificDate = new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`);

  // Get day of week (0 = Sunday, 6 = Saturday)
  const pacificDayOfWeek = new Date(pacificTimeStr).getDay();

  // Calculate days to subtract to get to Sunday
  const daysToSubtract = pacificDayOfWeek;

  // Subtract days to get to Sunday
  pacificDate.setDate(pacificDate.getDate() - daysToSubtract);

  // Determine if we're in PST or PDT
  const jan = new Date(now.getFullYear(), 0, 1);
  const jul = new Date(now.getFullYear(), 6, 1);
  const stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  const isDST = now.getTimezoneOffset() < stdTimezoneOffset;

  // Create midnight Pacific Time for that Sunday
  const offset = isDST ? '-07:00' : '-08:00';
  const sundayMidnight = new Date(`${pacificDate.toISOString().split('T')[0]}T00:00:00${offset}`);

  return sundayMidnight;
}

// Helper function to get start of month in Pacific Time
function getStartOfMonthPacific(): Date {
  const now = new Date();

  // Convert current time to Pacific Time
  const pacificTimeStr = now.toLocaleString('en-US', {
    timeZone: 'America/Los_Angeles',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });

  // Parse the Pacific time string
  const [datePart] = pacificTimeStr.split(', ');
  const [month, day, year] = datePart.split('/');

  // Create date string for 1st of the month
  const firstOfMonth = `${year}-${month.padStart(2, '0')}-01`;

  // Determine if we're in PST or PDT
  const jan = new Date(now.getFullYear(), 0, 1);
  const jul = new Date(now.getFullYear(), 6, 1);
  const stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  const isDST = now.getTimezoneOffset() < stdTimezoneOffset;

  // Create midnight Pacific Time for the 1st of the month
  const offset = isDST ? '-07:00' : '-08:00';
  const monthStart = new Date(`${firstOfMonth}T00:00:00${offset}`);

  return monthStart;
}

// Helper function to format timestamp for display
function formatTimestamp(timestamp: Timestamp): string {
  const date = timestamp.toDate();
  const now = new Date();
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);

  const months = ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'];

  const month = months[date.getMonth()];
  const day = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const displayHours = hours % 12 || 12;

  // Check if today
  if (date.toDateString() === now.toDateString()) {
    return `Today at ${displayHours}:${minutes} ${ampm}`;
  }

  // Check if yesterday
  if (date.toDateString() === yesterday.toDateString()) {
    return `Yesterday at ${displayHours}:${minutes} ${ampm}`;
  }

  // Otherwise show full date
  return `${month} ${day} at ${displayHours}:${minutes} ${ampm}`;
}

// Helper function to get server config
async function getServerConfig(serverId: string): Promise<ServerConfig | null> {
  const doc = await db
    .collection('discord-data')
    .doc('serverConfig')
    .collection('configs')
    .doc(serverId)
    .get();

  if (!doc.exists) {
    return null;
  }

  return doc.data() as ServerConfig;
}

// Helper function to post session start to feed channel
async function postSessionStartToFeed(
  interaction: CommandInteraction | ModalSubmitInteraction,
  username: string,
  userId: string,
  avatarUrl: string,
  activity: string
) {
  try {
    const config = await getServerConfig(interaction.guildId!);

    if (!config || !config.feedChannelId) {
      // No feed channel configured - skip posting
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);

    if (!channel || !channel.isTextBased()) {
      console.error('Feed channel not found or not text-based');
      return;
    }

    const textChannel = channel as TextChannel;

    // Check bot permissions in the channel
    const botMember = await interaction.guild?.members.fetch(client.user!.id);
    const permissions = textChannel.permissionsFor(botMember!);

    if (!permissions?.has(PermissionFlagsBits.ViewChannel)) {
      console.error(`Bot lacks 'View Channel' permission in feed channel ${config.feedChannelId}`);
      return;
    }

    if (!permissions?.has(PermissionFlagsBits.SendMessages)) {
      console.error(`Bot lacks 'Send Messages' permission in feed channel ${config.feedChannelId}`);
      return;
    }

    // Create embed for session start
    const embed = new EmbedBuilder()
      .setColor(0x00FF00) // Green for "live"
      .setAuthor({
        name: `${username} üü¢`,
        iconURL: avatarUrl
      })
      .setDescription(`**@${username}** is live now working on **${activity}**!`);

    await textChannel.send({
      embeds: [embed]
    });
  } catch (error: any) {
    // Log detailed error for debugging
    if (error.code === 50001) {
      console.error(`Bot lacks access to feed channel. Please ensure the bot has 'View Channel' permission.`);
    } else if (error.code === 50013) {
      console.error(`Bot lacks permissions in feed channel. Please ensure the bot has 'Send Messages' and 'Embed Links' permissions.`);
    } else {
      console.error('Error posting session start to feed:', error);
    }
    // Don't throw - we don't want to fail the session start
  }
}

// Helper function to post VC session start to feed channel
async function postVCSessionStartToFeed(
  guildId: string,
  username: string,
  userId: string,
  avatarUrl: string,
  vcChannelId: string
) {
  try {
    const config = await getServerConfig(guildId);

    if (!config || !config.feedChannelId) {
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);
    if (!channel || !channel.isTextBased()) {
      return;
    }

    const textChannel = channel as TextChannel;

    // Create embed for VC session start with link
    const embed = new EmbedBuilder()
      .setColor(0x00FF00) // Green for "live"
      .setAuthor({
        name: `${username} üü¢`,
        iconURL: avatarUrl
      })
      .setDescription(`üéß **${username}** started studying in <#${vcChannelId}>`);

    await textChannel.send({
      embeds: [embed]
    });
  } catch (error) {
    console.error('Error posting VC session start to feed:', error);
  }
}

// Helper function to post to feed channel
async function postToFeed(
  interaction: CommandInteraction | ModalSubmitInteraction,
  username: string,
  userId: string,
  avatarUrl: string,
  activity: string,
  title: string,
  description: string,
  duration: number,
  endTime: Timestamp,
  sessionId: string,
  xpGained: number,
  newLevel?: number,
  achievementsUnlocked?: string[],
  intensity?: number
) {
  try {
    const config = await getServerConfig(interaction.guildId!);

    if (!config || !config.feedChannelId) {
      // No feed channel configured - skip posting
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);

    if (!channel || !channel.isTextBased()) {
      console.error('Feed channel not found or not text-based');
      return;
    }

    const textChannel = channel as TextChannel;

    // Check bot permissions in the channel
    const botMember = await interaction.guild?.members.fetch(client.user!.id);
    const permissions = textChannel.permissionsFor(botMember!);

    if (!permissions?.has(PermissionFlagsBits.ViewChannel)) {
      console.error(`Bot lacks 'View Channel' permission in feed channel ${config.feedChannelId}`);
      return;
    }

    if (!permissions?.has(PermissionFlagsBits.SendMessages)) {
      console.error(`Bot lacks 'Send Messages' permission in feed channel ${config.feedChannelId}`);
      return;
    }

    if (!permissions?.has(PermissionFlagsBits.AddReactions)) {
      console.error(`Bot lacks 'Add Reactions' permission in feed channel ${config.feedChannelId}`);
    }

    const durationStr = formatDuration(duration);

    // Get intensity display (visual bars)
    const getIntensityDisplay = (intensity?: number): string => {
      if (!intensity) return 'Not specified';

      // Create visual bar representation
      const filled = '‚ñà';
      const empty = '‚ñë';
      const bars = filled.repeat(intensity) + empty.repeat(5 - intensity);

      const labels = ['Light', 'Easy', 'Normal', 'Hard', 'Max'];
      return `${bars} ${labels[intensity - 1]}`;
    };

    // Create the Strava-like embed
    const embed = new EmbedBuilder()
      .setColor(0x0080FF) // Electric blue
      .setAuthor({
        name: `${username} completed a session!`,
        iconURL: avatarUrl
      })
      .setTitle(title)
      .setDescription(description)
      .addFields(
        { name: '‚è±Ô∏è Time', value: durationStr, inline: true },
        { name: 'üéØ Activity', value: activity, inline: true },
        { name: 'üí™ Intensity', value: getIntensityDisplay(intensity), inline: true },
        { name: '\u200b', value: `**‚ú® +${xpGained} XP Earned**`, inline: false }
      );

    const message = await textChannel.send({
      embeds: [embed]
    });

    // Track session post for social features
    await postService.createSessionPost(
      message.id,
      userId,
      username,
      interaction.guildId!,
      config.feedChannelId,
      sessionId,
      duration,
      xpGained,
      newLevel,
      achievementsUnlocked
    );

    // React with a heart if bot has permission
    if (permissions?.has(PermissionFlagsBits.AddReactions)) {
      await message.react('‚ù§Ô∏è');
    }
  } catch (error: any) {
    // Log detailed error for debugging
    if (error.code === 50001) {
      console.error(`Bot lacks access to feed channel. Please ensure the bot has 'View Channel' permission.`);
    } else if (error.code === 50013) {
      console.error(`Bot lacks permissions in feed channel. Please ensure the bot has 'Send Messages', 'Embed Links', and 'Add Reactions' permissions.`);
    } else {
      console.error('Error posting to feed:', error);
    }
    // Don't throw - we don't want to fail the session completion
  }
}

// Helper function to post streak milestone celebrations to feed
async function postStreakMilestone(
  interaction: CommandInteraction | ModalSubmitInteraction,
  username: string,
  avatarUrl: string,
  streak: number,
  totalSessions: number
) {
  try {
    const config = await getServerConfig(interaction.guildId!);

    if (!config || !config.feedChannelId) {
      // No feed channel configured - skip posting
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);

    if (!channel || !channel.isTextBased()) {
      console.error('Feed channel not found or not text-based');
      return;
    }

    const textChannel = channel as TextChannel;

    // Check bot permissions in the channel
    const botMember = await interaction.guild?.members.fetch(client.user!.id);
    const permissions = textChannel.permissionsFor(botMember!);

    if (!permissions?.has(PermissionFlagsBits.ViewChannel) || !permissions?.has(PermissionFlagsBits.SendMessages)) {
      console.error(`Bot lacks necessary permissions in feed channel ${config.feedChannelId}`);
      return;
    }

    // Determine message and emoji based on milestones
    let message = '';
    let emoji = '';
    let color = 0x00FF00; // Green
    let shouldCelebrate = false;

    if (totalSessions === 1) {
      // First session ever - only triggers once
      message = `**@${username}** just completed their first session! üéâ`;
      emoji = 'üéâ';
      color = 0x00FF00; // Green
      shouldCelebrate = true;
    } else if (streak === 7) {
      message = `**@${username}** hit a 7-day streak! üî•üî• A full week of grinding!`;
      emoji = 'üî•';
      color = 0xFF6B00; // Orange
      shouldCelebrate = true;
    } else if (streak === 30) {
      message = `**@${username}** reached a 30-day streak! üî•üî•üî• Unstoppable! üöÄ`;
      emoji = 'üî•';
      color = 0xFF0000; // Red
      shouldCelebrate = true;
    }

    // Only post if this is a milestone worth celebrating
    if (!shouldCelebrate) {
      return;
    }

    // Create milestone embed
    const embed = new EmbedBuilder()
      .setColor(color)
      .setAuthor({
        name: `${username} ${emoji}`,
        iconURL: avatarUrl
      })
      .setDescription(message);

    const milestoneMessage = await textChannel.send({
      embeds: [embed]
    });

    // React with appropriate emoji if bot has permission
    if (permissions?.has(PermissionFlagsBits.AddReactions)) {
      await milestoneMessage.react(emoji);

      // Add fire reactions for streaks
      if (streak === 7) {
        await milestoneMessage.react('üí™');
      } else if (streak === 30) {
        await milestoneMessage.react('üëë');
        await milestoneMessage.react('üí™');
      }
    }
  } catch (error) {
    console.error('Error posting streak milestone:', error);
    // Don't throw - we don't want to fail the session completion
  }
}

// Helper function to post achievement unlock celebrations to feed
async function postAchievementUnlock(
  interaction: CommandInteraction | ModalSubmitInteraction,
  username: string,
  avatarUrl: string,
  achievementIds: string[]
) {
  try {
    if (!achievementIds || achievementIds.length === 0) {
      return;
    }

    const config = await getServerConfig(interaction.guildId!);

    if (!config || !config.feedChannelId) {
      // No feed channel configured - skip posting
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);

    if (!channel || !channel.isTextBased()) {
      console.error('Feed channel not found or not text-based');
      return;
    }

    const textChannel = channel as TextChannel;

    // Check bot permissions in the channel
    const botMember = await interaction.guild?.members.fetch(client.user!.id);
    const permissions = textChannel.permissionsFor(botMember!);

    if (!permissions?.has(PermissionFlagsBits.ViewChannel) || !permissions?.has(PermissionFlagsBits.SendMessages)) {
      console.error(`Bot lacks necessary permissions in feed channel ${config.feedChannelId}`);
      return;
    }

    // Get achievement details
    const achievements = achievementIds.map(id => getAchievement(id)).filter(b => b !== undefined);
    if (achievements.length === 0) {
      return;
    }

    // Build achievement list with emojis, names, and descriptions
    const achievementList = achievements.map(b => `${b!.emoji} **${b!.name}**\n${b!.description}`).join('\n\n');
    const totalXP = achievements.reduce((sum, b) => sum + b!.xpReward, 0);

    const message = achievements.length === 1
      ? `**@${username}** unlocked a new achievement! üèÜ`
      : `**@${username}** unlocked ${achievements.length} new achievements! üèÜ`;

    // Create achievement unlock embed
    const embed = new EmbedBuilder()
      .setColor(0xFFD700) // Gold
      .setAuthor({
        name: `${username} üèÜ`,
        iconURL: avatarUrl
      })
      .setDescription(`${message}\n\n${achievementList}`)
      .setFooter({ text: `+${totalXP} bonus XP earned` });

    const achievementMessage = await textChannel.send({
      embeds: [embed]
    });

    // React with confetti if bot has permission
    if (permissions?.has(PermissionFlagsBits.AddReactions)) {
      await achievementMessage.react('üéâ');
    }
  } catch (error) {
    console.error('Error posting achievement unlock:', error);
    // Don't throw - we don't want to fail the session completion
  }
}

// Helper function to post level-up celebrations to feed
async function postLevelUp(
  interaction: CommandInteraction | ModalSubmitInteraction,
  username: string,
  avatarUrl: string,
  newLevel: number,
  oldLevel: number
) {
  try {
    const config = await getServerConfig(interaction.guildId!);

    if (!config || !config.feedChannelId) {
      // No feed channel configured - skip posting
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);

    if (!channel || !channel.isTextBased()) {
      console.error('Feed channel not found or not text-based');
      return;
    }

    const textChannel = channel as TextChannel;

    // Check bot permissions in the channel
    const botMember = await interaction.guild?.members.fetch(client.user!.id);
    const permissions = textChannel.permissionsFor(botMember!);

    if (!permissions?.has(PermissionFlagsBits.ViewChannel) || !permissions?.has(PermissionFlagsBits.SendMessages)) {
      console.error(`Bot lacks necessary permissions in feed channel ${config.feedChannelId}`);
      return;
    }

    // Calculate next level XP requirement and hours needed
    const currentXP = xpForLevel(newLevel);
    const nextLevelXP = xpForLevel(newLevel + 1);
    const xpNeeded = nextLevelXP - currentXP;
    const hoursNeeded = Math.ceil(xpNeeded / 100); // 100 XP per hour

    const levelDiff = newLevel - oldLevel;
    const levelMessage = levelDiff > 1
      ? `**@${username}** is now Level ${newLevel}! üéâ`
      : `**@${username}** is now Level ${newLevel}! üéâ`;

    // Create level-up embed
    const embed = new EmbedBuilder()
      .setColor(0x9B59B6) // Purple
      .setAuthor({
        name: `${username} üéâ`,
        iconURL: avatarUrl
      })
      .setDescription(levelMessage)
      .setFooter({ text: `About ${hoursNeeded} more ${hoursNeeded === 1 ? 'hour' : 'hours'} needed to reach Level ${newLevel + 1}!` });

    const levelUpMessage = await textChannel.send({
      embeds: [embed]
    });

    // React with celebration emojis if bot has permission
    if (permissions?.has(PermissionFlagsBits.AddReactions)) {
      await levelUpMessage.react('üéâ');
      await levelUpMessage.react('‚ú®');
    }
  } catch (error) {
    console.error('Error posting level-up:', error);
    // Don't throw - we don't want to fail the session completion
  }
}

// Helper function to post level-up celebrations to feed (for auto-posted VC sessions)
async function postLevelUpBasic(
  guildId: string,
  username: string,
  avatarUrl: string,
  newLevel: number,
  oldLevel: number
) {
  try {
    const config = await getServerConfig(guildId);

    if (!config || !config.feedChannelId) {
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);
    if (!channel || !channel.isTextBased()) {
      return;
    }

    const textChannel = channel as TextChannel;

    // Calculate next level XP requirement and hours needed
    const currentXP = xpForLevel(newLevel);
    const nextLevelXP = xpForLevel(newLevel + 1);
    const xpNeeded = nextLevelXP - currentXP;
    const hoursNeeded = Math.ceil(xpNeeded / 100); // 100 XP per hour

    const levelDiff = newLevel - oldLevel;
    const levelMessage = levelDiff > 1
      ? `**@${username}** is now Level ${newLevel}! üéâ`
      : `**@${username}** is now Level ${newLevel}! üéâ`;

    // Create level-up embed
    const embed = new EmbedBuilder()
      .setColor(0x9B59B6) // Purple
      .setAuthor({
        name: `${username} üéâ`,
        iconURL: avatarUrl
      })
      .setDescription(levelMessage)
      .setFooter({ text: `About ${hoursNeeded} more ${hoursNeeded === 1 ? 'hour' : 'hours'} needed to reach Level ${newLevel + 1}!` });

    const levelUpMessage = await textChannel.send({
      embeds: [embed]
    });

    // React with celebration emojis
    await levelUpMessage.react('üéâ').catch(() => {});
    await levelUpMessage.react('‚ú®').catch(() => {});
  } catch (error) {
    console.error('Error posting level-up:', error);
  }
}

// Helper function to post basic session completion to feed (for auto-posted VC sessions)
async function postBasicSessionToFeed(
  guildId: string,
  username: string,
  avatarUrl: string,
  duration: number,
  vcChannelId: string
) {
  try {
    const config = await getServerConfig(guildId);

    if (!config || !config.feedChannelId) {
      return;
    }

    const channel = await client.channels.fetch(config.feedChannelId);
    if (!channel || !channel.isTextBased()) {
      return;
    }

    const textChannel = channel as TextChannel;
    const durationStr = formatDuration(duration);

    // Create basic completion embed
    const embed = new EmbedBuilder()
      .setColor(0x0080FF) // Electric blue
      .setAuthor({
        name: `${username} completed a session!`,
        iconURL: avatarUrl
      })
      .setDescription(`Focused for **${durationStr}** in <#${vcChannelId}>`);

    const message = await textChannel.send({
      embeds: [embed]
    });

    // React with a heart
    await message.react('‚ù§Ô∏è').catch(() => {});
  } catch (error) {
    console.error('Error posting basic session to feed:', error);
  }
}

// Map to track auto-post timers
const autoPostTimers = new Map<string, NodeJS.Timeout>();

// Helper function to schedule auto-post after 1 hour
function scheduleAutoPost(userId: string, guildId: string) {
  // Clear existing timer if any
  if (autoPostTimers.has(userId)) {
    clearTimeout(autoPostTimers.get(userId)!);
  }

  // Schedule new timer for 10 minutes
  const timer = setTimeout(async () => {
    try {
      const session = await sessionService.getActiveSession(userId);

      if (!session || !session.pendingCompletion || !session.isVCSession) {
        return;
      }

      // Calculate final duration
      const duration = calculateDuration(
        session.startTime,
        session.pausedDuration,
        session.isPaused ? session.pausedAt : undefined
      );

      const endTime = Timestamp.now();

      // DELETE ACTIVE SESSION FIRST to prevent race condition/duplicate posts
      await sessionService.deleteActiveSession(session.userId);

      // Create completed session
      const sessionId = await sessionService.createCompletedSession({
        userId: session.userId,
        username: session.username,
        serverId: session.serverId,
        activity: 'VC Session',
        title: `Focus session in voice channel`,
        description: `Completed ${formatDuration(duration)} of focused work`,
        duration,
        startTime: session.startTime,
        endTime,
      });

      // Update stats and award XP
      const statsUpdate = await statsService.updateUserStats(
        session.userId,
        session.username,
        duration,
        'VC Session'
      );

      // Update completed session with XP gained (for leaderboards)
      await sessionService.updateCompletedSessionXP(sessionId, statsUpdate.xpGained);

      // Check for new achievements
      const newAchievements = await achievementService.checkAndAwardAchievements(session.userId);

      // Fetch user for avatar
      const user = await client.users.fetch(userId);
      const avatarUrl = user.displayAvatarURL({ size: 128 });

      // Send DM with XP and achievement info
      try {
        let xpMessage = '';
        if (statsUpdate.leveledUp) {
          xpMessage = `\n\nüéâ **LEVEL UP!** You're now Level ${statsUpdate.newLevel}!\n‚ú® +${statsUpdate.xpGained} XP earned!`;
        } else {
          xpMessage = `\n‚ú® +${statsUpdate.xpGained} XP earned!`;
        }

        let achievementMessage = '';
        if (newAchievements.length > 0) {
          const achievementDetails = newAchievements.map(id => getAchievement(id)).filter(b => b);
          const achievementList = achievementDetails.map(b => `${b!.emoji} **${b!.name}**`).join(', ');
          achievementMessage = `\nüèÜ **NEW ACHIEVEMENT${newAchievements.length > 1 ? 'S' : ''}!** ${achievementList}`;
        }

        await user.send(`‚è∞ Your VC session was automatically posted!\n\n**Duration:** ${formatDuration(duration)}${xpMessage}${achievementMessage}`);
      } catch (dmError) {
        console.log('Could not send auto-post DM to user');
      }

      // Post basic session to feed
      await postBasicSessionToFeed(
        guildId,
        session.username,
        avatarUrl,
        duration,
        session.vcChannelId!
      );

      // Post level-up celebration if applicable
      if (statsUpdate.leveledUp && statsUpdate.newLevel) {
        // Calculate old level from XP
        const currentXP = statsUpdate.stats.xp || 0;
        const oldXP = currentXP - statsUpdate.xpGained;
        const oldLevel = calculateLevel(oldXP);

        await postLevelUpBasic(
          guildId,
          session.username,
          avatarUrl,
          statsUpdate.newLevel,
          oldLevel
        );
      }

      // Clean up timer
      autoPostTimers.delete(userId);
    } catch (error) {
      console.error('Error in auto-post timer:', error);
    }
  }, 10 * 60 * 1000); // 10 minutes

  autoPostTimers.set(userId, timer);
}

// Helper function to cancel auto-post timer
function cancelAutoPost(userId: string) {
  if (autoPostTimers.has(userId)) {
    clearTimeout(autoPostTimers.get(userId)!);
    autoPostTimers.delete(userId);
  }
}

// Handle interactions
client.on('interactionCreate', async (interaction) => {
  // Handle modal submissions
  if (interaction.isModalSubmit()) {
    if (interaction.customId === 'manualSessionModal') {
      try {
        // Defer reply immediately to prevent double-submission
        await interaction.deferReply({ ephemeral: false });

        const user = interaction.user;
        const guildId = interaction.guildId;

        // Get modal inputs
        const activity = interaction.fields.getTextInputValue('activity');
        const title = interaction.fields.getTextInputValue('title');
        const description = interaction.fields.getTextInputValue('description');
        const durationInput = interaction.fields.getTextInputValue('duration');
        const intensityStr = interaction.fields.getTextInputValue('intensity');

        // Validate and parse intensity (1-5 scale)
        const intensity = parseInt(intensityStr, 10);
        if (isNaN(intensity) || intensity < 1 || intensity > 5) {
          await interaction.editReply({
            content: '‚ùå Invalid intensity value. Please enter a number between 1 and 5.',
          });
          return;
        }

        // Parse duration string (supports formats like "2h 30m", "1h", "45m", "90m")
        const parseDuration = (input: string): number | null => {
          const trimmed = input.trim().toLowerCase();

          // Try to match "Xh Ym" or "Xh" or "Ym" format
          const hourMinuteMatch = trimmed.match(/(\d+)\s*h(?:\s+(\d+)\s*m)?/);
          if (hourMinuteMatch) {
            const hours = parseInt(hourMinuteMatch[1], 10);
            const minutes = hourMinuteMatch[2] ? parseInt(hourMinuteMatch[2], 10) : 0;
            return (hours * 3600) + (minutes * 60);
          }

          // Try to match "Ym" format only
          const minuteMatch = trimmed.match(/^(\d+)\s*m$/);
          if (minuteMatch) {
            const minutes = parseInt(minuteMatch[1], 10);
            return minutes * 60;
          }

          return null;
        };

        const duration = parseDuration(durationInput);

        if (duration === null) {
          await interaction.editReply({
            content: '‚ùå Invalid duration format. Please use formats like "2h 30m", "1h", or "45m".',
          });
          return;
        }

        if (duration <= 0) {
          await interaction.editReply({
            content: '‚ùå Duration must be greater than 0.',
          });
          return;
        }

        // Create timestamps
        const endTime = Timestamp.now();
        const startTime = Timestamp.fromMillis(endTime.toMillis() - (duration * 1000));

        // Create completed session
        const sessionId = await sessionService.createCompletedSession({
          userId: user.id,
          username: user.username,
          serverId: guildId!,
          activity,
          title,
          description,
          duration,
          startTime,
          endTime,
          intensity,
        });

        // Update stats and award XP
        const statsUpdate = await statsService.updateUserStats(
          user.id,
          user.username,
          duration,
          activity,
          intensity
        );

        // Update completed session with XP gained (for leaderboards)
        await sessionService.updateCompletedSessionXP(sessionId, statsUpdate.xpGained);

        // Check for new achievements
        const newAchievements = await achievementService.checkAndAwardAchievements(user.id);

        const durationStr = formatDuration(duration);

        // Build XP message with intensity multiplier display
        const intensityLabels = ['Light', 'Easy', 'Normal', 'Hard', 'Max'];
        const intensityLabel = intensityLabels[intensity - 1];
        const multiplierText = `(${statsUpdate.xpMultiplier}x ${intensityLabel} intensity)`;

        let xpMessage = '';
        if (statsUpdate.leveledUp) {
          xpMessage = `\n\nüéâ **LEVEL UP!** You're now Level ${statsUpdate.newLevel}!\n‚ú® +${statsUpdate.xpGained} XP earned ${multiplierText}`;
        } else {
          xpMessage = `\n\n‚ú® +${statsUpdate.xpGained} XP earned ${multiplierText}`;
        }

        await interaction.editReply({
          content: `‚úÖ Manual session logged! (${durationStr})${xpMessage}\n\nYour session has been saved and posted to the feed.`,
        });

        // Get user's avatar URL
        const avatarUrl = user.displayAvatarURL({ size: 128 });

        // Post to feed channel
        await postToFeed(
          interaction,
          user.username,
          user.id,
          avatarUrl,
          activity,
          title,
          description,
          duration,
          endTime,
          sessionId,
          statsUpdate.xpGained,
          statsUpdate.leveledUp ? statsUpdate.newLevel : undefined,
          newAchievements.length > 0 ? newAchievements : undefined,
          intensity
        );

        // Get updated stats to check for streak milestones
        const updatedStats = await statsService.getUserStats(user.id);
        if (updatedStats) {
          // Post streak milestone celebration if applicable
          await postStreakMilestone(
            interaction,
            user.username,
            avatarUrl,
            updatedStats.currentStreak,
            updatedStats.totalSessions
          );
        }

        // Post achievement unlock celebration if applicable
        if (newAchievements.length > 0) {
          await postAchievementUnlock(
            interaction,
            user.username,
            avatarUrl,
            newAchievements
          );
        }

        // Post level-up celebration if applicable
        if (statsUpdate.leveledUp && statsUpdate.newLevel) {
          // Calculate old level from XP
          const currentXP = statsUpdate.stats.xp || 0;
          const oldXP = currentXP - statsUpdate.xpGained;
          const oldLevel = calculateLevel(oldXP);

          await postLevelUp(
            interaction,
            user.username,
            avatarUrl,
            statsUpdate.newLevel,
            oldLevel
          );
        }
      } catch (error) {
        console.error('Error handling manual session modal:', error);

        const errorMessage = 'An error occurred while logging your manual session. Please try again.';

        try {
          if (interaction.replied || interaction.deferred) {
            await interaction.followUp({ content: errorMessage, ephemeral: true });
          } else {
            await interaction.reply({ content: errorMessage, ephemeral: true });
          }
        } catch (replyError) {
          console.error('Could not send error message to user:', replyError);
        }
      }
    } else if (interaction.customId === 'endSessionModal') {
      try {
        const user = interaction.user;
        const guildId = interaction.guildId;

        // Get modal inputs
        const title = interaction.fields.getTextInputValue('title');
        const description = interaction.fields.getTextInputValue('description');
        const intensityStr = interaction.fields.getTextInputValue('intensity');

        // Validate and parse intensity (1-5 scale)
        const intensity = parseInt(intensityStr, 10);
        if (isNaN(intensity) || intensity < 1 || intensity > 5) {
          await interaction.reply({
            content: '‚ùå Invalid intensity value. Please enter a number between 1 and 5.',
            ephemeral: true,
          });
          return;
        }

        // Defer reply immediately to prevent timeout (we have complex processing ahead)
        await interaction.deferReply({ ephemeral: false });

        // Get active session
        const session = await sessionService.getActiveSession(user.id);

        if (!session) {
          await interaction.editReply({
            content: 'No active session found! It may have been cancelled or already ended.',
          });
          return;
        }

        // Calculate final duration
        const duration = calculateDuration(
          session.startTime,
          session.pausedDuration,
          session.isPaused ? session.pausedAt : undefined
        );

        const endTime = Timestamp.now();

        // DELETE ACTIVE SESSION FIRST to prevent race condition/duplicate submissions
        await sessionService.deleteActiveSession(user.id);

        // Create completed session
        const sessionId = await sessionService.createCompletedSession({
          userId: user.id,
          username: user.username,
          serverId: guildId!,
          activity: session.activity,
          title,
          description,
          duration,
          startTime: session.startTime,
          endTime,
          intensity,
        });

        // Update stats and award XP
        const statsUpdate = await statsService.updateUserStats(
          user.id,
          user.username,
          duration,
          session.activity,
          intensity
        );

        // Update completed session with XP gained (for leaderboards)
        await sessionService.updateCompletedSessionXP(sessionId, statsUpdate.xpGained);

        // Check for new achievements
        const newAchievements = await achievementService.checkAndAwardAchievements(user.id);

        const durationStr = formatDuration(duration);

        // Build XP message with intensity multiplier display
        const intensityLabels = ['Light', 'Easy', 'Normal', 'Hard', 'Max'];
        const intensityLabel = intensityLabels[intensity - 1];
        const multiplierText = `(${statsUpdate.xpMultiplier}x ${intensityLabel} intensity)`;

        let xpMessage = '';
        if (statsUpdate.leveledUp) {
          xpMessage = `\n\nüéâ **LEVEL UP!** You're now Level ${statsUpdate.newLevel}!\n‚ú® +${statsUpdate.xpGained} XP earned ${multiplierText}`;
        } else {
          xpMessage = `\n\n‚ú® +${statsUpdate.xpGained} XP earned ${multiplierText}`;
        }

        await interaction.editReply({
          content: `‚úÖ Session completed! (${durationStr})${xpMessage}\n\nYour session has been saved and posted to the feed.`,
        });

        // Get user's avatar URL
        const avatarUrl = user.displayAvatarURL({ size: 128 });

        // Post to feed channel
        await postToFeed(
          interaction,
          user.username,
          user.id,
          avatarUrl,
          session.activity,
          title,
          description,
          duration,
          endTime,
          sessionId,
          statsUpdate.xpGained,
          statsUpdate.leveledUp ? statsUpdate.newLevel : undefined,
          newAchievements.length > 0 ? newAchievements : undefined,
          intensity
        );

        // Get updated stats to check for streak milestones
        const updatedStats = await statsService.getUserStats(user.id);
        if (updatedStats) {
          // Post streak milestone celebration if applicable
          await postStreakMilestone(
            interaction,
            user.username,
            avatarUrl,
            updatedStats.currentStreak,
            updatedStats.totalSessions
          );
        }

        // Post achievement unlock celebration if applicable
        if (newAchievements.length > 0) {
          await postAchievementUnlock(
            interaction,
            user.username,
            avatarUrl,
            newAchievements
          );
        }

        // Post level-up celebration if applicable
        if (statsUpdate.leveledUp && statsUpdate.newLevel) {
          // Calculate old level from XP
          const currentXP = statsUpdate.stats.xp || 0;
          const oldXP = currentXP - statsUpdate.xpGained;
          const oldLevel = calculateLevel(oldXP);

          await postLevelUp(
            interaction,
            user.username,
            avatarUrl,
            statsUpdate.newLevel,
            oldLevel
          );
        }
      } catch (error) {
        console.error('Error handling end session modal:', error);

        const errorMessage = 'An error occurred while completing your session. Please try again.';

        try {
          // We always defer at the start, so use editReply
          await interaction.editReply({ content: errorMessage });
        } catch (replyError) {
          console.error('Could not send error message to user:', replyError);
        }
      }
    } else if (interaction.customId.includes('event_builder:') && interaction.customId.includes(':modal_')) {
      // Event builder field modal submissions
      const parts = interaction.customId.split(':');
      const builderId = `${parts[0]}:${parts[1]}:${parts[2]}`;
      const modalType = parts[3].replace('modal_', '');

      const builderState = eventBuilders.get(builderId);

      if (!builderState || builderState.userId !== interaction.user.id) {
        await interaction.reply({
          content: '‚ùå This event builder has expired or does not belong to you.',
          ephemeral: true
        });
        return;
      }

      try {
        await interaction.deferUpdate();

        // Update helper function
        const updateBuilderEmbed = (state: EventBuilderState): EmbedBuilder => {
          const embed = new EmbedBuilder()
            .setColor(0x0080FF)
            .setTitle('üìÖ Create Study Event')
            .setDescription('Use the buttons and dropdown below to configure your event.')
            .addFields(
              { name: 'üìù Title', value: state.title || '*Not set*', inline: false },
              { name: 'üìç Location', value: state.location || '*Not set*', inline: false },
              {
                name: '‚è∞ Start Time',
                value: state.startTime ? `<t:${Math.floor(state.startTime.getTime() / 1000)}:F>` : '*Not set*',
                inline: true
              },
              { name: '‚è±Ô∏è Duration', value: state.duration ? `${state.duration} minutes` : '*Not set*', inline: true },
              {
                name: 'üéØ Study Type',
                value: state.studyType
                  ? (state.studyType === 'custom' && state.customType ? `Custom: ${state.customType}` : state.studyType)
                  : '*Not set*',
                inline: false
              },
              { name: 'üë• Max Attendees', value: state.maxAttendees ? state.maxAttendees.toString() : 'Unlimited', inline: true },
              { name: 'üìù Description', value: state.description || '*None*', inline: false }
            )
            .setFooter({ text: 'Configure all required fields (*) then click Create Event' });

          return embed;
        };

        // Process different modal types
        if (modalType === 'title') {
          builderState.title = interaction.fields.getTextInputValue('title');
        } else if (modalType === 'location') {
          builderState.location = interaction.fields.getTextInputValue('location');
        } else if (modalType === 'time') {
          const dateTimeStr = interaction.fields.getTextInputValue('time');

          // Parse date/time (simple parser for common formats)
          const parseDateTime = (input: string): Date | null => {
          const now = new Date();
          const trimmed = input.trim().toLowerCase();

          // Try ISO format first (YYYY-MM-DD HH:MM)
          const isoMatch = trimmed.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{1,2}):(\d{2})/);
          if (isoMatch) {
            const [, year, month, day, hour, minute] = isoMatch;
            const date = new Date(
              parseInt(year),
              parseInt(month) - 1,
              parseInt(day),
              parseInt(hour),
              parseInt(minute)
            );
            return date;
          }

          // Try "tomorrow HH:MM" or "tomorrow H pm/am"
          if (trimmed.includes('tomorrow')) {
            const timeMatch = trimmed.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
            if (timeMatch) {
              const [, hourStr, minuteStr, meridiem] = timeMatch;
              let hour = parseInt(hourStr);
              const minute = minuteStr ? parseInt(minuteStr) : 0;

              if (meridiem === 'pm' && hour !== 12) hour += 12;
              if (meridiem === 'am' && hour === 12) hour = 0;

              const tomorrow = new Date(now);
              tomorrow.setDate(tomorrow.getDate() + 1);
              tomorrow.setHours(hour, minute, 0, 0);
              return tomorrow;
            }
          }

          // Try "today HH:MM" or "today H pm/am"
          if (trimmed.includes('today')) {
            const timeMatch = trimmed.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
            if (timeMatch) {
              const [, hourStr, minuteStr, meridiem] = timeMatch;
              let hour = parseInt(hourStr);
              const minute = minuteStr ? parseInt(minuteStr) : 0;

              if (meridiem === 'pm' && hour !== 12) hour += 12;
              if (meridiem === 'am' && hour === 12) hour = 0;

              const today = new Date(now);
              today.setHours(hour, minute, 0, 0);
              return today;
            }
          }

          return null;
        };

          };

          const startTime = parseDateTime(dateTimeStr);
          if (!startTime) {
            await interaction.followUp({
              content: '‚ùå Invalid date/time format. Please use formats like:\n- `2025-01-20 18:00`\n- `tomorrow 6pm`\n- `today 14:30`',
              ephemeral: true
            });
            return;
          }

          if (startTime.getTime() < Date.now()) {
            await interaction.followUp({
              content: '‚ùå Event start time must be in the future.',
              ephemeral: true
            });
            return;
          }

          builderState.startTime = startTime;
        } else if (modalType === 'duration') {
          const durationStr = interaction.fields.getTextInputValue('duration');
          const duration = parseInt(durationStr, 10);

          if (isNaN(duration) || duration <= 0) {
            await interaction.followUp({
              content: '‚ùå Invalid duration. Please enter a positive number (in minutes).',
              ephemeral: true
            });
            return;
          }

          builderState.duration = duration;
        } else if (modalType === 'max') {
          const maxStr = interaction.fields.getTextInputValue('max').trim();

          if (maxStr) {
            const max = parseInt(maxStr, 10);
            if (isNaN(max) || max <= 0) {
              await interaction.followUp({
                content: '‚ùå Invalid max attendees. Please enter a positive number or leave blank for unlimited.',
                ephemeral: true
              });
              return;
            }
            builderState.maxAttendees = max;
          } else {
            builderState.maxAttendees = undefined;
          }
        } else if (modalType === 'description') {
          const desc = interaction.fields.getTextInputValue('description').trim();
          builderState.description = desc || undefined;
        } else if (modalType === 'custom_type') {
          const customType = interaction.fields.getTextInputValue('custom_type').trim();
          builderState.customType = customType;
          builderState.studyType = 'custom';
        }

        // Update the builder embed
        const updatedEmbed = updateBuilderEmbed(builderState);

        // Recreate components
        const studyTypeSelect = new StringSelectMenuBuilder()
          .setCustomId(`${builderId}:study_type`)
          .setPlaceholder('Select study type')
          .addOptions([
            { label: 'Silent Study', description: 'Quiet, focused work session', value: 'silent', emoji: 'ü§´' },
            { label: 'Conversation Allowed', description: 'Talking and discussion permitted', value: 'conversation', emoji: 'üí¨' },
            { label: 'Pomodoro Session', description: 'Structured breaks (25min work, 5min break)', value: 'pomodoro', emoji: 'üçÖ' },
            { label: 'Custom', description: 'Define your own study style', value: 'custom', emoji: '‚ú®' }
          ]);

        const setTitleBtn = new ButtonBuilder().setCustomId(`${builderId}:set_title`).setLabel('Set Title').setStyle(ButtonStyle.Secondary).setEmoji('üìù');
        const setLocationBtn = new ButtonBuilder().setCustomId(`${builderId}:set_location`).setLabel('Set Location').setStyle(ButtonStyle.Secondary).setEmoji('üìç');
        const setTimeBtn = new ButtonBuilder().setCustomId(`${builderId}:set_time`).setLabel('Set Time').setStyle(ButtonStyle.Secondary).setEmoji('‚è∞');
        const setDurationBtn = new ButtonBuilder().setCustomId(`${builderId}:set_duration`).setLabel('Set Duration').setStyle(ButtonStyle.Secondary).setEmoji('‚è±Ô∏è');
        const setMaxBtn = new ButtonBuilder().setCustomId(`${builderId}:set_max`).setLabel('Set Max').setStyle(ButtonStyle.Secondary).setEmoji('üë•');
        const setDescBtn = new ButtonBuilder().setCustomId(`${builderId}:set_description`).setLabel('Set Description').setStyle(ButtonStyle.Secondary).setEmoji('üìÑ');
        const createBtn = new ButtonBuilder().setCustomId(`${builderId}:create`).setLabel('Create Event').setStyle(ButtonStyle.Success).setEmoji('‚úÖ');
        const cancelBtn = new ButtonBuilder().setCustomId(`${builderId}:cancel`).setLabel('Cancel').setStyle(ButtonStyle.Danger).setEmoji('‚ùå');

        const selectRow = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(studyTypeSelect);
        const buttonRow1 = new ActionRowBuilder<ButtonBuilder>().addComponents(setTitleBtn, setLocationBtn, setTimeBtn, setDurationBtn);
        const buttonRow2 = new ActionRowBuilder<ButtonBuilder>().addComponents(setMaxBtn, setDescBtn);
        const buttonRow3 = new ActionRowBuilder<ButtonBuilder>().addComponents(createBtn, cancelBtn);

        await interaction.editReply({
          embeds: [updatedEmbed],
          components: [selectRow, buttonRow1, buttonRow2, buttonRow3]
        });
      } catch (error) {
        console.error('Error updating event builder:', error);
        await interaction.followUp({
          content: '‚ùå An error occurred. Please try again.',
          ephemeral: true
        });
      }
    }
    return;
  }

  // Handle button interactions
  if (interaction.isButton()) {
    const user = interaction.user;

    // Event builder buttons
    if (interaction.customId.includes('event_builder:')) {
      const parts = interaction.customId.split(':');
      const builderId = `${parts[0]}:${parts[1]}:${parts[2]}`;
      const action = parts[3];

      const builderState = eventBuilders.get(builderId);

      if (!builderState || builderState.userId !== user.id) {
        await interaction.reply({
          content: '‚ùå This event builder has expired or does not belong to you.',
          ephemeral: true
        });
        return;
      }

      // Cancel button
      if (action === 'cancel') {
        eventBuilders.delete(builderId);
        await interaction.update({
          content: '‚ùå Event creation cancelled.',
          embeds: [],
          components: []
        });
        return;
      }

      // Create button
      if (action === 'create') {
        // Validate required fields
        if (!builderState.title || !builderState.location || !builderState.startTime || !builderState.duration || !builderState.studyType) {
          await interaction.reply({
            content: '‚ùå Please fill in all required fields (Title, Location, Time, Duration, Study Type).',
            ephemeral: true
          });
          return;
        }

        await interaction.deferUpdate();

        try {
          const guildId = interaction.guildId!;

          // Create the event
          const event = await eventService.createEvent(
            guildId,
            user.id,
            user.username,
            builderState.title,
            builderState.location,
            builderState.startTime,
            builderState.duration,
            builderState.studyType,
            {
              description: builderState.description,
              maxAttendees: builderState.maxAttendees,
              customType: builderState.customType,
            }
          );

          // Post event to events channel
          const config = await getServerConfig(guildId);
          if (config && config.eventsChannelId) {
            try {
              const eventsChannel = (await client.channels.fetch(config.eventsChannelId)) as TextChannel;

              const studyTypeEmoji = {
                silent: 'ü§´',
                conversation: 'üí¨',
                pomodoro: 'üçÖ',
                custom: '‚ú®'
              };

              const eventEmbed = new EmbedBuilder()
                .setColor(0x0080FF)
                .setAuthor({
                  name: user.username,
                  iconURL: user.displayAvatarURL({ size: 128 }),
                })
                .setTitle(`${studyTypeEmoji[builderState.studyType]} ${builderState.title}`)
                .setDescription(builderState.description || 'Join this study session!')
                .addFields(
                  { name: 'üìç Location', value: builderState.location, inline: false },
                  { name: '‚è∞ Start Time', value: `<t:${Math.floor(builderState.startTime.getTime() / 1000)}:F>\n<t:${Math.floor(builderState.startTime.getTime() / 1000)}:R>`, inline: true },
                  { name: '‚è±Ô∏è Duration', value: `${builderState.duration} minutes`, inline: true },
                  { name: 'üéØ Type', value: builderState.studyType === 'custom' ? builderState.customType || builderState.studyType : builderState.studyType, inline: true },
                  {
                    name: 'üë• Attendees',
                    value: builderState.maxAttendees
                      ? `1/${builderState.maxAttendees} (${builderState.maxAttendees - 1} spots left)`
                      : '1 person attending',
                    inline: false
                  },
                  { name: 'üìû Contact', value: `DM <@${user.id}> for more info`, inline: false }
                )
                .setFooter({ text: `Event ID: ${event.eventId}` })
                .setTimestamp();

              const joinButton = new ButtonBuilder()
                .setCustomId(`event_join:${event.eventId}`)
                .setLabel('Join Event')
                .setStyle(ButtonStyle.Success)
                .setEmoji('‚úÖ');

              const leaveButton = new ButtonBuilder()
                .setCustomId(`event_leave:${event.eventId}`)
                .setLabel('Leave Event')
                .setStyle(ButtonStyle.Danger)
                .setEmoji('‚ùå');

              const buttonRow = new ActionRowBuilder<ButtonBuilder>().addComponents(joinButton, leaveButton);

              const message = await eventsChannel.send({
                content: 'üìÖ **New Study Event Created!**',
                embeds: [eventEmbed],
                components: [buttonRow],
              });

              await eventService.updateEventMessage(event.eventId, message.id, eventsChannel.id);
            } catch (error) {
              console.error('Error posting event to events channel:', error);
            }
          }

          // Clean up builder state
          eventBuilders.delete(builderId);

          await interaction.editReply({
            content: `‚úÖ Event created successfully!\n\n**${builderState.title}**\nüìç ${builderState.location}\n‚è∞ <t:${Math.floor(builderState.startTime.getTime() / 1000)}:F>`,
            embeds: [],
            components: []
          });
        } catch (error) {
          console.error('Error creating event:', error);
          await interaction.followUp({
            content: '‚ùå An error occurred while creating the event. Please try again.',
            ephemeral: true
          });
        }
        return;
      }

      // Set field buttons - show modals
      if (action === 'set_title') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_title`)
          .setTitle('Set Event Title');

        const titleInput = new TextInputBuilder()
          .setCustomId('title')
          .setLabel('Event Title')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('e.g., Late Night Study Session')
          .setRequired(true)
          .setMaxLength(100);

        if (builderState.title) {
          titleInput.setValue(builderState.title);
        }

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(titleInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
        return;
      }

      if (action === 'set_location') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_location`)
          .setTitle('Set Event Location');

        const locationInput = new TextInputBuilder()
          .setCustomId('location')
          .setLabel('Location')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('e.g., Library - 3rd floor, table near windows')
          .setRequired(true)
          .setMaxLength(200);

        if (builderState.location) {
          locationInput.setValue(builderState.location);
        }

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(locationInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
        return;
      }

      if (action === 'set_time') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_time`)
          .setTitle('Set Event Time');

        const timeInput = new TextInputBuilder()
          .setCustomId('time')
          .setLabel('Start Date & Time')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('e.g., 2025-01-20 18:00 or tomorrow 6pm')
          .setRequired(true);

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(timeInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
        return;
      }

      if (action === 'set_duration') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_duration`)
          .setTitle('Set Event Duration');

        const durationInput = new TextInputBuilder()
          .setCustomId('duration')
          .setLabel('Duration (in minutes)')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('e.g., 120')
          .setRequired(true);

        if (builderState.duration) {
          durationInput.setValue(builderState.duration.toString());
        }

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(durationInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
        return;
      }

      if (action === 'set_max') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_max`)
          .setTitle('Set Max Attendees');

        const maxInput = new TextInputBuilder()
          .setCustomId('max')
          .setLabel('Max Attendees (leave blank for unlimited)')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('e.g., 10')
          .setRequired(false);

        if (builderState.maxAttendees) {
          maxInput.setValue(builderState.maxAttendees.toString());
        }

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(maxInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
        return;
      }

      if (action === 'set_description') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_description`)
          .setTitle('Set Event Description');

        const descInput = new TextInputBuilder()
          .setCustomId('description')
          .setLabel('Description (optional)')
          .setStyle(TextInputStyle.Paragraph)
          .setPlaceholder('Add any additional details about the event...')
          .setRequired(false)
          .setMaxLength(500);

        if (builderState.description) {
          descInput.setValue(builderState.description);
        }

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(descInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
        return;
      }
    }

    // Event join button
    if (interaction.customId.startsWith('event_join:')) {
      const eventId = interaction.customId.split(':')[1];

      await interaction.deferReply({ ephemeral: true });

      try {
        const result = await eventService.joinEvent(eventId, user.id, user.username);

        await interaction.editReply({
          content: result.success ? `‚úÖ ${result.message}` : `‚ùå ${result.message}`,
        });

        // Update the event embed if successful
        if (result.success && interaction.message) {
          const event = await eventService.getEvent(eventId);
          if (event) {
            const embed = interaction.message.embeds[0];
            const newEmbed = EmbedBuilder.from(embed);

            // Update attendees field
            const spotsText = event.maxAttendees
              ? `${event.attendees.length}/${event.maxAttendees} (${event.maxAttendees - event.attendees.length} spots left)`
              : `${event.attendees.length} ${event.attendees.length === 1 ? 'person' : 'people'} attending`;

            // Find and update the attendees field
            const fields = newEmbed.data.fields || [];
            const attendeesFieldIndex = fields.findIndex(f => f.name === 'üë• Attendees');
            if (attendeesFieldIndex !== -1) {
              fields[attendeesFieldIndex].value = spotsText;
              newEmbed.setFields(fields);
            }

            await interaction.message.edit({ embeds: [newEmbed] });
          }
        }
      } catch (error) {
        console.error('Error joining event:', error);
        await interaction.editReply({
          content: '‚ùå An error occurred while joining the event. Please try again.',
        });
      }
      return;
    }

    // Event leave button
    if (interaction.customId.startsWith('event_leave:')) {
      const eventId = interaction.customId.split(':')[1];

      await interaction.deferReply({ ephemeral: true });

      try {
        const result = await eventService.leaveEvent(eventId, user.id);

        await interaction.editReply({
          content: result.success ? `‚úÖ ${result.message}` : `‚ùå ${result.message}`,
        });

        // Update the event embed if successful
        if (result.success && interaction.message) {
          const event = await eventService.getEvent(eventId);
          if (event) {
            const embed = interaction.message.embeds[0];
            const newEmbed = EmbedBuilder.from(embed);

            // Update attendees field
            const spotsText = event.maxAttendees
              ? `${event.attendees.length}/${event.maxAttendees} (${event.maxAttendees - event.attendees.length} spots left)`
              : `${event.attendees.length} ${event.attendees.length === 1 ? 'person' : 'people'} attending`;

            // Find and update the attendees field
            const fields = newEmbed.data.fields || [];
            const attendeesFieldIndex = fields.findIndex(f => f.name === 'üë• Attendees');
            if (attendeesFieldIndex !== -1) {
              fields[attendeesFieldIndex].value = spotsText;
              newEmbed.setFields(fields);
            }

            await interaction.message.edit({ embeds: [newEmbed] });
          }
        }
      } catch (error) {
        console.error('Error leaving event:', error);
        await interaction.editReply({
          content: '‚ùå An error occurred while leaving the event. Please try again.',
        });
      }
      return;
    }

    // Event join from list button
    if (interaction.customId === 'event_list_join') {
      await interaction.reply({
        content: 'Please copy the **Event ID** from the event list above and use this command:\n`/events` then click the Join button on the specific event, or join via the event post in the feed channel.',
        ephemeral: true,
      });
      return;
    }

    // Event leave from list button
    if (interaction.customId === 'event_list_leave') {
      await interaction.reply({
        content: 'Please copy the **Event ID** from the event list above and use the Leave button on the specific event post in the feed channel, or use `/cancelevent <event-id>` if you created it.',
        ephemeral: true,
      });
      return;
    }
  }

  // Handle select menu interactions
  if (interaction.isStringSelectMenu()) {
    // Event builder study type selection
    if (interaction.customId.includes('event_builder:') && interaction.customId.includes(':study_type')) {
      const parts = interaction.customId.split(':');
      const builderId = `${parts[0]}:${parts[1]}:${parts[2]}`;
      const selectedType = interaction.values[0] as 'silent' | 'conversation' | 'pomodoro' | 'custom';

      const builderState = eventBuilders.get(builderId);

      if (!builderState || builderState.userId !== interaction.user.id) {
        await interaction.reply({
          content: '‚ùå This event builder has expired or does not belong to you.',
          ephemeral: true
        });
        return;
      }

      // If custom type, show a modal to get custom description
      if (selectedType === 'custom') {
        const modal = new ModalBuilder()
          .setCustomId(`${builderId}:modal_custom_type`)
          .setTitle('Custom Study Type');

        const customTypeInput = new TextInputBuilder()
          .setCustomId('custom_type')
          .setLabel('Describe your study type')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('e.g., Group Project Work, Code Review Session')
          .setRequired(true)
          .setMaxLength(100);

        const row = new ActionRowBuilder<TextInputBuilder>().addComponents(customTypeInput);
        modal.addComponents(row);

        await interaction.showModal(modal);

        // Store that we selected custom (will be updated when modal submitted)
        builderState.studyType = 'custom';
        return;
      }

      // Update state
      builderState.studyType = selectedType;
      builderState.customType = undefined; // Clear custom type if switching away from custom

      await interaction.deferUpdate();

      // Update embed helper
      const updateBuilderEmbed = (state: EventBuilderState): EmbedBuilder => {
        const embed = new EmbedBuilder()
          .setColor(0x0080FF)
          .setTitle('üìÖ Create Study Event')
          .setDescription('Use the buttons and dropdown below to configure your event.')
          .addFields(
            { name: 'üìù Title', value: state.title || '*Not set*', inline: false },
            { name: 'üìç Location', value: state.location || '*Not set*', inline: false },
            {
              name: '‚è∞ Start Time',
              value: state.startTime ? `<t:${Math.floor(state.startTime.getTime() / 1000)}:F>` : '*Not set*',
              inline: true
            },
            { name: '‚è±Ô∏è Duration', value: state.duration ? `${state.duration} minutes` : '*Not set*', inline: true },
            {
              name: 'üéØ Study Type',
              value: state.studyType
                ? (state.studyType === 'custom' && state.customType ? `Custom: ${state.customType}` : state.studyType)
                : '*Not set*',
              inline: false
            },
            { name: 'üë• Max Attendees', value: state.maxAttendees ? state.maxAttendees.toString() : 'Unlimited', inline: true },
            { name: 'üìù Description', value: state.description || '*None*', inline: false }
          )
          .setFooter({ text: 'Configure all required fields (*) then click Create Event' });

        return embed;
      };

      const updatedEmbed = updateBuilderEmbed(builderState);

      // Recreate components
      const studyTypeSelect = new StringSelectMenuBuilder()
        .setCustomId(`${builderId}:study_type`)
        .setPlaceholder('Select study type')
        .addOptions([
          { label: 'Silent Study', description: 'Quiet, focused work session', value: 'silent', emoji: 'ü§´' },
          { label: 'Conversation Allowed', description: 'Talking and discussion permitted', value: 'conversation', emoji: 'üí¨' },
          { label: 'Pomodoro Session', description: 'Structured breaks (25min work, 5min break)', value: 'pomodoro', emoji: 'üçÖ' },
          { label: 'Custom', description: 'Define your own study style', value: 'custom', emoji: '‚ú®' }
        ]);

      const setTitleBtn = new ButtonBuilder().setCustomId(`${builderId}:set_title`).setLabel('Set Title').setStyle(ButtonStyle.Secondary).setEmoji('üìù');
      const setLocationBtn = new ButtonBuilder().setCustomId(`${builderId}:set_location`).setLabel('Set Location').setStyle(ButtonStyle.Secondary).setEmoji('üìç');
      const setTimeBtn = new ButtonBuilder().setCustomId(`${builderId}:set_time`).setLabel('Set Time').setStyle(ButtonStyle.Secondary).setEmoji('‚è∞');
      const setDurationBtn = new ButtonBuilder().setCustomId(`${builderId}:set_duration`).setLabel('Set Duration').setStyle(ButtonStyle.Secondary).setEmoji('‚è±Ô∏è');
      const setMaxBtn = new ButtonBuilder().setCustomId(`${builderId}:set_max`).setLabel('Set Max').setStyle(ButtonStyle.Secondary).setEmoji('üë•');
      const setDescBtn = new ButtonBuilder().setCustomId(`${builderId}:set_description`).setLabel('Set Description').setStyle(ButtonStyle.Secondary).setEmoji('üìÑ');
      const createBtn = new ButtonBuilder().setCustomId(`${builderId}:create`).setLabel('Create Event').setStyle(ButtonStyle.Success).setEmoji('‚úÖ');
      const cancelBtn = new ButtonBuilder().setCustomId(`${builderId}:cancel`).setLabel('Cancel').setStyle(ButtonStyle.Danger).setEmoji('‚ùå');

      const selectRow = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(studyTypeSelect);
      const buttonRow1 = new ActionRowBuilder<ButtonBuilder>().addComponents(setTitleBtn, setLocationBtn, setTimeBtn, setDurationBtn);
      const buttonRow2 = new ActionRowBuilder<ButtonBuilder>().addComponents(setMaxBtn, setDescBtn);
      const buttonRow3 = new ActionRowBuilder<ButtonBuilder>().addComponents(createBtn, cancelBtn);

      await interaction.editReply({
        embeds: [updatedEmbed],
        components: [selectRow, buttonRow1, buttonRow2, buttonRow3]
      });
      return;
    }

    if (interaction.customId === 'leaderboard_timeframe') {
      const selectedValue = interaction.values[0];
      const user = interaction.user;
      const guildId = interaction.guildId;

      // Defer the update to prevent timeout
      await interaction.deferUpdate();

      // Get data for all timeframes
      const today = getStartOfDayPacific();
      const weekStart = getStartOfWeekPacific();
      const monthStart = getStartOfMonthPacific();

      const [dailyAll, weeklyAll, monthlyAll] = await Promise.all([
        sessionService.getTopUsers(Timestamp.fromDate(today), 20, guildId!),
        sessionService.getTopUsers(Timestamp.fromDate(weekStart), 20, guildId!),
        sessionService.getTopUsers(Timestamp.fromDate(monthStart), 20, guildId!),
      ]);

      let embed: EmbedBuilder;

      if (selectedValue === 'overview') {
        // Overview: Top 3 from each timeframe + user position
        const formatLeaderboard = (allUsers: Array<{ userId: string; username: string; totalDuration: number }>, emoji: string, label: string) => {
          if (allUsers.length === 0) return `${emoji} **${label}**\nNo data yet`;

          const lines: string[] = [];
          const userPosition = allUsers.findIndex(u => u.userId === user.id);

          // Add top 3
          for (let i = 0; i < Math.min(3, allUsers.length); i++) {
            const u = allUsers[i];
            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : 'ü•â';
            lines.push(`${medal} **${u.username}** - ${(u.totalDuration / 3600).toFixed(1)}h`);
          }

          // Add current user if not in top 3
          if (userPosition > 2) {
            const current = allUsers[userPosition];
            lines.push(`**${userPosition + 1}. ${current.username} - ${(current.totalDuration / 3600).toFixed(1)}h**`);
          }

          return `${emoji} **${label}**\n${lines.join('\n')}`;
        };

        embed = new EmbedBuilder()
          .setColor(0xFFD700)
          .setTitle('üèÜ Your Leaderboard Position')
          .addFields(
            { name: '\u200B', value: formatLeaderboard(dailyAll, 'üìÖ', 'Daily'), inline: false },
            { name: '\u200B', value: formatLeaderboard(weeklyAll, 'üìä', 'Weekly'), inline: false },
            { name: '\u200B', value: formatLeaderboard(monthlyAll, 'üåü', 'Monthly'), inline: false }
          )
          .setFooter({ text: 'Use the dropdown below to view full leaderboards' });
      } else if (selectedValue === 'xp') {
        // XP Leaderboard
        const xpUsers = await statsService.getTopUsersByXP(20);

        if (xpUsers.length === 0) {
          embed = new EmbedBuilder()
            .setColor(0xFFD700)
            .setTitle('‚ö° XP Leaderboard')
            .setDescription('No XP data yet! Complete sessions to earn XP! üöÄ')
            .setFooter({ text: 'Use the dropdown below to view other timeframes' });
        } else {
          const top10 = xpUsers.slice(0, 10);
          const ranks: string[] = [];
          const names: string[] = [];
          const xpLevels: string[] = [];

          top10.forEach((u, index) => {
            const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
            ranks.push(medal);
            names.push(`**${u.username}** üèÜ ${u.achievementCount}`);
            xpLevels.push(`Lvl ${u.level} ‚Ä¢ ${u.xp.toLocaleString()} XP`);
          });

          // Add current user if not in top 10
          const userPosition = xpUsers.findIndex(u => u.userId === user.id);
          if (userPosition >= 10) {
            const currentUser = xpUsers[userPosition];
            ranks.push(`**#${userPosition + 1}**`);
            names.push(`**${currentUser.username}** üèÜ ${currentUser.achievementCount}`);
            xpLevels.push(`**Lvl ${currentUser.level} ‚Ä¢ ${currentUser.xp.toLocaleString()} XP**`);
          }

          embed = new EmbedBuilder()
            .setColor(0xFFD700)
            .setTitle('‚ö° XP Leaderboard')
            .addFields(
              { name: 'Rank', value: ranks.join('\n'), inline: true },
              { name: 'Name', value: names.join('\n'), inline: true },
              { name: 'Level ‚Ä¢ XP', value: xpLevels.join('\n'), inline: true }
            )
            .setFooter({ text: 'Complete sessions to earn XP and level up! üí™' });
        }
      } else {
        // Full leaderboard for specific time-based timeframe (sorted by hours)
        let users: Array<{ userId: string; username: string; totalDuration: number; sessionCount: number }>;
        let title: string;
        let emoji: string;

        if (selectedValue === 'daily') {
          users = dailyAll;
          title = 'üìÖ Daily Leaderboard';
          emoji = 'üìÖ';
        } else if (selectedValue === 'weekly') {
          users = weeklyAll;
          title = 'üìä Weekly Leaderboard';
          emoji = 'üìä';
        } else {
          users = monthlyAll;
          title = 'üåü Monthly Leaderboard';
          emoji = 'üåü';
        }

        if (users.length === 0) {
          embed = new EmbedBuilder()
            .setColor(0xFFD700)
            .setTitle(title)
            .setDescription('No sessions completed in this timeframe yet! Be the first! üöÄ')
            .setFooter({ text: 'Use the dropdown below to view other timeframes' });
        } else {
          const top10 = users.slice(0, 10);
          const ranks: string[] = [];
          const names: string[] = [];
          const hours: string[] = [];

          top10.forEach((u, index) => {
            const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
            ranks.push(medal);
            names.push(`**${u.username}**`);
            hours.push(`${(u.totalDuration / 3600).toFixed(1)}h`);
          });

          // Add current user if not in top 10
          const userPosition = users.findIndex(u => u.userId === user.id);
          if (userPosition >= 10) {
            const currentUser = users[userPosition];
            ranks.push(`**#${userPosition + 1}**`);
            names.push(`**${currentUser.username}**`);
            hours.push(`**${(currentUser.totalDuration / 3600).toFixed(1)}h**`);
          }

          embed = new EmbedBuilder()
            .setColor(0xFFD700)
            .setTitle(title)
            .addFields(
              { name: 'Rank', value: ranks.join('\n'), inline: true },
              { name: 'Name', value: names.join('\n'), inline: true },
              { name: 'Hours', value: hours.join('\n'), inline: true }
            )
            .setFooter({ text: 'Ranked by hours studied in this timeframe. Keep grinding! üí™' });
        }
      }

      // Keep the same select menu
      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('leaderboard_timeframe')
        .setPlaceholder('Select a timeframe to view')
        .addOptions([
          {
            label: 'Overview',
            description: 'Top 3 from each timeframe + your position',
            value: 'overview',
            emoji: 'üèÜ',
          },
          {
            label: 'Daily Leaderboard',
            description: 'Full top 10 daily rankings by hours',
            value: 'daily',
            emoji: 'üìÖ',
          },
          {
            label: 'Weekly Leaderboard',
            description: 'Full top 10 weekly rankings by hours',
            value: 'weekly',
            emoji: 'üìä',
          },
          {
            label: 'Monthly Leaderboard',
            description: 'Full top 10 monthly rankings by hours',
            value: 'monthly',
            emoji: 'üåü',
          },
          {
            label: 'XP Leaderboard',
            description: 'Top 10 by total XP and level',
            value: 'xp',
            emoji: '‚ö°',
          },
        ]);

      const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(selectMenu);

      await interaction.editReply({ embeds: [embed], components: [row] });
      return;
    }

    // Goal completion dropdown handler
    if (interaction.customId.startsWith('goal_complete:')) {
      const userId = interaction.customId.split(':')[1];
      const goalId = interaction.values[0];

      // Only allow the owner to interact with their goal menu
      if (interaction.user.id !== userId) {
        await interaction.reply({
          content: 'This goal menu belongs to someone else!',
          ephemeral: true,
        });
        return;
      }

      await interaction.deferUpdate();

      try {
        // Complete the goal
        const result = await dailyGoalService.completeGoal(userId, goalId);
        const { goal, xpAwarded } = result;

        // Award XP to user
        let xpResult;
        try {
          xpResult = await xpService.awardXP(userId, xpAwarded, `Completed goal: ${goal.text}`);
        } catch (error) {
          console.log('User has no stats yet, skipping XP award');
        }

        // Build XP text
        const xpText = xpResult && xpResult.leveledUp
          ? `+${xpAwarded} XP ‚Ä¢ üéâ Level ${xpResult.newLevel}!`
          : `+${xpAwarded} XP`;

        // Create completion embed
        const embed = new EmbedBuilder()
          .setColor(0x00FF00)
          .setTitle('üéâ Goal Completed!')
          .setDescription(`**${goal.text}**`)
          .addFields(
            { name: 'XP Earned', value: xpText, inline: true },
            { name: 'Difficulty', value: `${goal.difficulty.charAt(0).toUpperCase() + goal.difficulty.slice(1)}`, inline: true }
          )
          .setFooter({ text: 'Great work! Keep setting and completing goals!' })
          .setTimestamp();

        await interaction.editReply({ embeds: [embed], components: [] });
        return;
      } catch (error) {
        console.error('Error completing goal:', error);
        await interaction.editReply({
          content: 'An error occurred while completing your goal. Please try again.',
          components: [],
        });
        return;
      }
    }

    // Achievement filter dropdown handler
    if (interaction.customId.startsWith('achievement_filter:')) {
      const userId = interaction.customId.split(':')[1];
      const selectedValue = interaction.values[0];

      // Only allow the owner to interact with their achievement menu
      if (interaction.user.id !== userId) {
        await interaction.reply({
          content: 'This achievement menu belongs to someone else!',
          ephemeral: true,
        });
        return;
      }

      await interaction.deferUpdate();

      const userAchievements = await achievementService.getUserAchievements(userId);
      const allAchievements = getAllAchievements();

      // Get unlocked achievement IDs
      const unlockedIds = new Set(userAchievements.map(b => b.id));

      // Separate unlocked and locked achievements
      const unlockedAchievements = allAchievements.filter(b => unlockedIds.has(b.id)).sort((a, b) => a.order - b.order);
      const lockedAchievements = allAchievements.filter(b => !unlockedIds.has(b.id)).sort((a, b) => a.order - b.order);

      // Create achievement list based on selection
      let achievementList: string;
      if (selectedValue === 'unlocked') {
        achievementList = unlockedAchievements.length > 0
          ? unlockedAchievements.map(b => `${b.emoji} **${b.name}** - *${b.description}*`).join('\n')
          : '*No achievements unlocked yet. Keep studying to earn your first achievement!*';
      } else {
        achievementList = lockedAchievements.length > 0
          ? lockedAchievements.map(b => `üîí ${b.emoji} **${b.name}** - *${b.description}*`).join('\n')
          : '*You\'ve unlocked all achievements! Amazing work!*';
      }

      const user = await interaction.client.users.fetch(userId);
      const avatarUrl = user.displayAvatarURL({ size: 128 });

      const embed = new EmbedBuilder()
        .setColor(0xFFD700) // Gold
        .setTitle(`üèÜ Your Achievements (${unlockedAchievements.length}/${allAchievements.length})`)
        .setDescription(achievementList)
        .setFooter({
          text: user.username,
          iconURL: avatarUrl
        });

      // Recreate dropdown menu with updated default
      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId(`achievement_filter:${userId}`)
        .setPlaceholder('Filter achievements')
        .addOptions([
          {
            label: 'Unlocked',
            description: `View your ${unlockedAchievements.length} unlocked achievements`,
            value: 'unlocked',
            emoji: '‚úÖ',
            default: selectedValue === 'unlocked',
          },
          {
            label: 'Locked',
            description: `View ${lockedAchievements.length} achievements you haven't earned yet`,
            value: 'locked',
            emoji: 'üîí',
            default: selectedValue === 'locked',
          },
        ]);

      const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(selectMenu);

      await interaction.editReply({ embeds: [embed], components: [row] });
      return;
    }
  }

  if (!interaction.isChatInputCommand()) return;

  const { commandName, user, guildId } = interaction;

  // Log command usage
  console.log(`[${new Date().toISOString()}] ${user.username} (${user.id}) used /${commandName} in guild ${guildId}`);

  try {
    // /ping command
    if (commandName === 'ping') {
      await interaction.reply({ content: 'Pong! üèì', ephemeral: true });
      return;
    }

    // /help command
    if (commandName === 'help') {
      const embed = new EmbedBuilder()
        .setColor(0x0080FF)
        .setTitle('üìö Study Together Bot - Commands')
        .setDescription('Track your productivity and compete with friends!')
        .addFields(
          {
            name: 'üéØ Session Management',
            value:
              '`/start {activity}` - Start a new session\n' +
              '`/time` - Check your current session status\n' +
              '`/pause` - Pause your active session\n' +
              '`/resume` - Resume your paused session\n' +
              '`/end` - Complete and share your session\n' +
              '`/cancel` - Cancel session without saving\n' +
              '`/manual` - Log a past session manually',
            inline: false
          },
          {
            name: 'üìä Statistics & Leaderboards',
            value:
              '`/stats` - View your personal statistics\n' +
              '`/leaderboard` - Interactive leaderboard with daily/weekly/monthly views\n' +
              '`/achievements` - View your achievements\n' +
              '`/profile [@user]` - View detailed user profile',
            inline: false
          },
          {
            name: 'üë• Social',
            value:
              '`/live` - See who\'s currently studying',
            inline: false
          },
          {
            name: '‚öôÔ∏è Server Setup (Admin Only)',
            value:
              '`/setup-feed {channel}` - Set feed channel for session posts\n' +
              '`/setup-focus-room {voice-channel}` - Enable auto-tracking in voice channel\n' +
              '`/set-welcome-channel {channel}` - Set welcome channel for new members',
            inline: false
          },
          {
            name: 'üí° Tips',
            value:
              '‚Ä¢ Earn XP and level up by completing sessions (10 XP/hour + bonuses)\n' +
              '‚Ä¢ Unlock 20 achievements by hitting milestones\n' +
              '‚Ä¢ React to others\' session posts to unlock social achievements\n' +
              '‚Ä¢ Voice channel sessions auto-track when you join a focus room\n' +
              '‚Ä¢ Build streaks by completing sessions daily',
            inline: false
          }
        )
        .setFooter({ text: 'Start your journey with /start {activity}' });

      await interaction.reply({
        embeds: [embed],
        ephemeral: true,
      });
      return;
    }

    // /goal command
    if (commandName === 'goal') {
      const subcommand = interaction.options.getSubcommand();

      if (subcommand === 'add') {
        // /goal add
        const goalText = interaction.options.getString('goal', true);
        const difficulty = interaction.options.getString('difficulty', true) as 'easy' | 'medium' | 'hard';

        await interaction.deferReply({ ephemeral: false });

        try {
          // Add the goal
          const newGoal = await dailyGoalService.addGoal(user.id, user.username, goalText, difficulty);

          const xpAmount = difficulty === 'easy' ? 50 : difficulty === 'medium' ? 100 : 200;

          const embed = new EmbedBuilder()
            .setColor(0x00FF00)
            .setTitle('‚úÖ Goal Added!')
            .setDescription(`**${goalText}**`)
            .addFields(
              { name: 'Difficulty', value: `${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`, inline: true },
              { name: 'Reward', value: `${xpAmount} XP upon completion`, inline: true }
            )
            .setFooter({ text: 'Use /goal complete to mark as done!' })
            .setTimestamp();

          await interaction.editReply({ embeds: [embed] });
          return;
        } catch (error) {
          console.error('Error adding goal:', error);
          await interaction.editReply({
            content: 'An error occurred while adding your goal. Please try again.',
          });
          return;
        }
      }

      if (subcommand === 'complete') {
        // /goal complete
        await interaction.deferReply({ ephemeral: false });

        try {
          // Get active goals
          const activeGoals = await dailyGoalService.getActiveGoals(user.id);

          if (activeGoals.length === 0) {
            await interaction.editReply({
              content: 'You have no active goals! Use `/goal add` to create one.',
            });
            return;
          }

          // Create select menu for goal selection
          const selectMenu = new StringSelectMenuBuilder()
            .setCustomId(`goal_complete:${user.id}`)
            .setPlaceholder('Select a goal to mark as complete')
            .addOptions(
              activeGoals.map((goal) => {
                const xpAmount = goal.difficulty === 'easy' ? 50 : goal.difficulty === 'medium' ? 100 : 200;

                return {
                  label: goal.text.substring(0, 100), // Discord limit
                  description: `${goal.difficulty.charAt(0).toUpperCase() + goal.difficulty.slice(1)} - ${xpAmount} XP`,
                  value: goal.id,
                };
              })
            );

          const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(selectMenu);

          const embed = new EmbedBuilder()
            .setColor(0x0080FF)
            .setTitle('üéØ Complete a Goal')
            .setDescription('Select which goal you completed:')
            .setFooter({ text: `${activeGoals.length} active ${activeGoals.length === 1 ? 'goal' : 'goals'}` });

          await interaction.editReply({ embeds: [embed], components: [row] });
          return;
        } catch (error) {
          console.error('Error showing goals for completion:', error);
          await interaction.editReply({
            content: 'An error occurred while loading your goals. Please try again.',
          });
          return;
        }
      }

      if (subcommand === 'list') {
        // /goal list
        await interaction.deferReply({ ephemeral: false });

        try {
          const allGoals = await dailyGoalService.getAllGoals(user.id);

          if (allGoals.length === 0) {
            await interaction.editReply({
              content: 'You have no goals yet! Use `/goal add` to create one.',
            });
            return;
          }

          const activeGoals = allGoals.filter(g => !g.isCompleted);
          const completedGoals = allGoals.filter(g => g.isCompleted);

          const embed = new EmbedBuilder()
            .setColor(0xFFD700)
            .setTitle('üìã Your Goals');

          // Add active goals
          if (activeGoals.length > 0) {
            const activeList = activeGoals.map((goal) => {
              const xpAmount = goal.difficulty === 'easy' ? 50 : goal.difficulty === 'medium' ? 100 : 200;
              return `**${goal.text}** (${xpAmount} XP)`;
            }).join('\n');

            embed.addFields({ name: 'üéØ Active Goals', value: activeList, inline: false });
          } else {
            embed.addFields({ name: 'üéØ Active Goals', value: 'No active goals! Use `/goal add` to create one.', inline: false });
          }

          // Show completed count only
          embed.setFooter({
            text: `${activeGoals.length} active ‚Ä¢ ${completedGoals.length} completed`
          });

          await interaction.editReply({ embeds: [embed] });
          return;
        } catch (error) {
          console.error('Error listing goals:', error);
          await interaction.editReply({
            content: 'An error occurred while loading your goals. Please try again.',
          });
          return;
        }
      }
    }

    // /createevent command
    if (commandName === 'createevent') {
      await interaction.deferReply({ ephemeral: true });

      // Create initial event builder embed
      const builderId = `event_builder:${user.id}:${Date.now()}`;

      // Initialize builder state
      eventBuilders.set(builderId, {
        userId: user.id
      });

      const builderEmbed = new EmbedBuilder()
        .setColor(0x0080FF)
        .setTitle('üìÖ Create Study Event')
        .setDescription('Use the buttons and dropdown below to configure your event.')
        .addFields(
          { name: 'üìù Title', value: '*Not set*', inline: false },
          { name: 'üìç Location', value: '*Not set*', inline: false },
          { name: '‚è∞ Start Time', value: '*Not set*', inline: true },
          { name: '‚è±Ô∏è Duration', value: '*Not set*', inline: true },
          { name: 'üéØ Study Type', value: '*Not set*', inline: false },
          { name: 'üë• Max Attendees', value: 'Unlimited', inline: true },
          { name: 'üìù Description', value: '*None*', inline: false }
        )
        .setFooter({ text: 'Configure all required fields (*) then click Create Event' });

      // Study type dropdown
      const studyTypeSelect = new StringSelectMenuBuilder()
        .setCustomId(`${builderId}:study_type`)
        .setPlaceholder('Select study type')
        .addOptions([
          {
            label: 'Silent Study',
            description: 'Quiet, focused work session',
            value: 'silent',
            emoji: 'ü§´'
          },
          {
            label: 'Conversation Allowed',
            description: 'Talking and discussion permitted',
            value: 'conversation',
            emoji: 'üí¨'
          },
          {
            label: 'Pomodoro Session',
            description: 'Structured breaks (25min work, 5min break)',
            value: 'pomodoro',
            emoji: 'üçÖ'
          },
          {
            label: 'Custom',
            description: 'Define your own study style',
            value: 'custom',
            emoji: '‚ú®'
          }
        ]);

      // Action buttons
      const setTitleBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:set_title`)
        .setLabel('Set Title')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìù');

      const setLocationBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:set_location`)
        .setLabel('Set Location')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìç');

      const setTimeBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:set_time`)
        .setLabel('Set Time')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚è∞');

      const setDurationBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:set_duration`)
        .setLabel('Set Duration')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚è±Ô∏è');

      const setMaxBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:set_max`)
        .setLabel('Set Max')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üë•');

      const setDescBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:set_description`)
        .setLabel('Set Description')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìÑ');

      const createBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:create`)
        .setLabel('Create Event')
        .setStyle(ButtonStyle.Success)
        .setEmoji('‚úÖ');

      const cancelBtn = new ButtonBuilder()
        .setCustomId(`${builderId}:cancel`)
        .setLabel('Cancel')
        .setStyle(ButtonStyle.Danger)
        .setEmoji('‚ùå');

      const selectRow = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(studyTypeSelect);
      const buttonRow1 = new ActionRowBuilder<ButtonBuilder>().addComponents(setTitleBtn, setLocationBtn, setTimeBtn, setDurationBtn);
      const buttonRow2 = new ActionRowBuilder<ButtonBuilder>().addComponents(setMaxBtn, setDescBtn);
      const buttonRow3 = new ActionRowBuilder<ButtonBuilder>().addComponents(createBtn, cancelBtn);

      await interaction.editReply({
        embeds: [builderEmbed],
        components: [selectRow, buttonRow1, buttonRow2, buttonRow3]
      });
      return;
    }

    // /events command
    if (commandName === 'events') {
      await interaction.deferReply({ ephemeral: false });

      try {
        const events = await eventService.getUpcomingEvents(guildId!);

        if (events.length === 0) {
          await interaction.editReply({
            content: 'No upcoming events! Use `/createevent` to create one.',
          });
          return;
        }

        const embed = new EmbedBuilder()
          .setColor(0x0080FF)
          .setTitle('üìÖ Upcoming Study Events')
          .setDescription(`${events.length} event${events.length === 1 ? '' : 's'} scheduled`)
          .setTimestamp();

        // Add each event as a field
        for (const event of events.slice(0, 10)) {
          const startTime = event.startTime.toDate();
          const discordTimestamp = `<t:${Math.floor(startTime.getTime() / 1000)}:F>`;
          const relativeTime = `<t:${Math.floor(startTime.getTime() / 1000)}:R>`;

          const studyTypeEmoji = {
            silent: 'ü§´',
            conversation: 'üí¨',
            pomodoro: 'üçÖ',
            custom: '‚ú®'
          };

          const spotsText = event.maxAttendees
            ? `${event.attendees.length}/${event.maxAttendees} spots filled`
            : `${event.attendees.length} attending`;

          embed.addFields({
            name: `${studyTypeEmoji[event.studyType]} ${event.title}`,
            value: [
              `üìç **Location:** ${event.location}`,
              `‚è∞ **When:** ${discordTimestamp} (${relativeTime})`,
              `‚è±Ô∏è **Duration:** ${event.duration} minutes`,
              `üë• **Attendees:** ${spotsText}`,
              `üéØ **Type:** ${event.studyType === 'custom' ? event.customType : event.studyType}`,
              event.description ? `üìù ${event.description}` : '',
              `**Event ID:** \`${event.eventId}\``
            ].filter(Boolean).join('\n'),
            inline: false
          });
        }

        if (events.length > 10) {
          embed.setFooter({ text: `Showing first 10 of ${events.length} events` });
        }

        // Add buttons for joining/leaving events
        const joinButton = new ButtonBuilder()
          .setCustomId('event_list_join')
          .setLabel('Join Event')
          .setStyle(ButtonStyle.Success)
          .setEmoji('‚úÖ');

        const leaveButton = new ButtonBuilder()
          .setCustomId('event_list_leave')
          .setLabel('Leave Event')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('‚ùå');

        const buttonRow = new ActionRowBuilder<ButtonBuilder>().addComponents(joinButton, leaveButton);

        await interaction.editReply({ embeds: [embed], components: [buttonRow] });
        return;
      } catch (error) {
        console.error('Error fetching events:', error);
        await interaction.editReply({
          content: 'An error occurred while fetching events. Please try again.',
        });
        return;
      }
    }

    // /myevents command
    if (commandName === 'myevents') {
      await interaction.deferReply({ ephemeral: true });

      try {
        const events = await eventService.getUserEvents(user.id, guildId!);

        if (events.length === 0) {
          await interaction.editReply({
            content: 'You haven\'t RSVP\'d to any events yet! Use `/events` to see upcoming events.',
          });
          return;
        }

        const embed = new EmbedBuilder()
          .setColor(0xFFD700)
          .setTitle('üìÖ Your Events')
          .setDescription(`You're attending ${events.length} event${events.length === 1 ? '' : 's'}`)
          .setTimestamp();

        // Add each event as a field
        for (const event of events) {
          const startTime = event.startTime.toDate();
          const discordTimestamp = `<t:${Math.floor(startTime.getTime() / 1000)}:F>`;
          const relativeTime = `<t:${Math.floor(startTime.getTime() / 1000)}:R>`;

          const isCreator = event.creatorId === user.id;

          embed.addFields({
            name: `${isCreator ? 'üëë ' : ''}${event.title}`,
            value: [
              `üìç **Location:** ${event.location}`,
              `‚è∞ **When:** ${discordTimestamp} (${relativeTime})`,
              `‚è±Ô∏è **Duration:** ${event.duration} minutes`,
              isCreator ? 'üëë You created this event' : '',
              `**Event ID:** \`${event.eventId}\``
            ].filter(Boolean).join('\n'),
            inline: false
          });
        }

        await interaction.editReply({ embeds: [embed] });
        return;
      } catch (error) {
        console.error('Error fetching user events:', error);
        await interaction.editReply({
          content: 'An error occurred while fetching your events. Please try again.',
        });
        return;
      }
    }

    // /cancelevent command
    if (commandName === 'cancelevent') {
      const eventId = interaction.options.getString('event', true);

      await interaction.deferReply({ ephemeral: true });

      try {
        const result = await eventService.cancelEvent(eventId, user.id);

        if (!result.success) {
          await interaction.editReply({
            content: result.message,
          });
          return;
        }

        // Get the event to notify attendees
        const event = await eventService.getEvent(eventId);
        if (event && event.messageId && event.channelId) {
          try {
            const channel = await client.channels.fetch(event.channelId) as TextChannel;
            if (channel) {
              const message = await channel.messages.fetch(event.messageId);
              if (message) {
                // Update the message to show it's cancelled
                const cancelledEmbed = new EmbedBuilder()
                  .setColor(0xFF0000)
                  .setTitle(`‚ùå CANCELLED: ${event.title}`)
                  .setDescription(`This event has been cancelled by the organizer.`)
                  .addFields(
                    { name: 'üìç Location', value: event.location, inline: true },
                    { name: '‚è∞ Was scheduled for', value: `<t:${Math.floor(event.startTime.toDate().getTime() / 1000)}:F>`, inline: true }
                  )
                  .setTimestamp();

                await message.edit({ embeds: [cancelledEmbed], components: [] });
              }
            }
          } catch (error) {
            console.error('Error updating event message:', error);
          }
        }

        await interaction.editReply({
          content: '‚úÖ Event cancelled successfully.',
        });
        return;
      } catch (error) {
        console.error('Error cancelling event:', error);
        await interaction.editReply({
          content: 'An error occurred while cancelling the event. Please try again.',
        });
        return;
      }
    }

    // /start command
    if (commandName === 'start') {
      const activity = interaction.options.getString('activity', true);

      // Check if user already has an active session
      const existingSession = await sessionService.getActiveSession(user.id);

      if (existingSession) {
        await interaction.reply({
          content:
            'You already have an active session! Use /end to complete it first.',
          ephemeral: true,
        });
        return;
      }

      // Create new session
      await sessionService.createActiveSession(
        user.id,
        user.username,
        guildId!,
        activity
      );

      await interaction.reply({
        content: `üöÄ You're live! Your session is now active.\n\n**Working on:** ${activity}`,
        ephemeral: true,
      });

      // Get user's avatar URL and post to feed
      const avatarUrl = user.displayAvatarURL({ size: 128 });
      await postSessionStartToFeed(
        interaction,
        user.username,
        user.id,
        avatarUrl,
        activity
      );

      return;
    }

    // /time command
    if (commandName === 'time') {
      await interaction.deferReply({ ephemeral: false });

      const session = await sessionService.getActiveSession(user.id);

      if (!session) {
        await interaction.editReply({
          content:
            'No active session. Use /start {activity} to begin tracking!',
        });
        return;
      }

      const elapsed = calculateDuration(
        session.startTime,
        session.pausedDuration,
        session.isPaused ? session.pausedAt : undefined
      );

      const elapsedStr = formatDuration(elapsed);
      const pauseStatus = session.isPaused ? '‚è∏Ô∏è Paused' : '‚ñ∂Ô∏è Active';

      await interaction.editReply({
        content: `**Current Session**

**Status:** ${pauseStatus}
**Activity:** ${session.activity}
**Elapsed Time:** ${elapsedStr}`,
      });
      return;
    }

    // /pause command
    if (commandName === 'pause') {
      const session = await sessionService.getActiveSession(user.id);

      if (!session) {
        await interaction.reply({
          content: 'No active session to pause.',
          ephemeral: false,
        });
        return;
      }

      if (session.isPaused) {
        await interaction.reply({
          content: 'Session is already paused.',
          ephemeral: false,
        });
        return;
      }

      await sessionService.updateActiveSession(user.id, {
        isPaused: true,
        pausedAt: Timestamp.now(),
      });

      await interaction.reply({
        content: '‚è∏Ô∏è Session paused. Use /resume when ready to continue.',
        ephemeral: false,
      });
      return;
    }

    // /resume command
    if (commandName === 'resume') {
      const session = await sessionService.getActiveSession(user.id);

      if (!session) {
        await interaction.reply({
          content: 'No active session to resume.',
          ephemeral: false,
        });
        return;
      }

      if (!session.isPaused) {
        await interaction.reply({
          content: 'Session is not paused.',
          ephemeral: false,
        });
        return;
      }

      // Calculate pause duration
      const pauseDuration =
        (Date.now() - session.pausedAt!.toMillis()) / 1000;
      const newPausedDuration = session.pausedDuration + pauseDuration;

      await sessionService.updateActiveSession(user.id, {
        isPaused: false,
        pausedAt: null as any, // Remove pausedAt field
        pausedDuration: newPausedDuration,
      });

      const elapsed = calculateDuration(
        session.startTime,
        newPausedDuration,
        undefined
      );
      const elapsedStr = formatDuration(elapsed);

      await interaction.reply({
        content: `‚ñ∂Ô∏è Session resumed!\n\n**Elapsed Time:** ${elapsedStr}`,
        ephemeral: false,
      });
      return;
    }

    // /cancel command
    if (commandName === 'cancel') {
      const session = await sessionService.getActiveSession(user.id);

      if (!session) {
        await interaction.reply({
          content: 'No active session to cancel.',
          ephemeral: false,
        });
        return;
      }

      // Cancel auto-post timer if it's a VC session
      if (session.isVCSession && session.pendingCompletion) {
        cancelAutoPost(user.id);
      }

      await sessionService.deleteActiveSession(user.id);

      await interaction.reply({
        content:
          '‚ùå Session cancelled. No stats were updated and nothing was posted to the feed.',
        ephemeral: false,
      });
      return;
    }

    // /end command
    if (commandName === 'end') {
      // Check if command is used in a server (not DMs)
      if (!guildId) {
        await interaction.reply({
          content: '‚ùå Please use `/end` in your server to post your session to the feed!',
          ephemeral: true,
        });
        return;
      }

      const session = await sessionService.getActiveSession(user.id);

      if (!session) {
        await interaction.reply({
          content: 'No active session found! Use /start first.',
          ephemeral: false,
        });
        return;
      }

      // If this is a VC session with pending completion, cancel auto-post timer
      if (session.isVCSession && session.pendingCompletion) {
        cancelAutoPost(user.id);
      }

      // Calculate duration to show in modal
      const duration = calculateDuration(
        session.startTime,
        session.pausedDuration,
        session.isPaused ? session.pausedAt : undefined
      );
      const durationStr = formatDuration(duration);

      // Create modal for session completion
      const modal = new ModalBuilder()
        .setCustomId('endSessionModal')
        .setTitle(`Complete Session (${durationStr})`);

      // Title input
      const titleInput = new TextInputBuilder()
        .setCustomId('title')
        .setLabel('Session Title')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('e.g., Finished chapter 5, Fixed login bug')
        .setRequired(true)
        .setMaxLength(100);

      // Description input
      const descriptionInput = new TextInputBuilder()
        .setCustomId('description')
        .setLabel('What did you accomplish?')
        .setStyle(TextInputStyle.Paragraph)
        .setPlaceholder('Share what you worked on and what you achieved...')
        .setRequired(true)
        .setMaxLength(1000);

      // Intensity input (1-5 scale)
      const intensityInput = new TextInputBuilder()
        .setCustomId('intensity')
        .setLabel('Session Intensity (1-5)')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('1=Light, 2=Easy, 3=Normal, 4=Hard, 5=Max Effort')
        .setRequired(true)
        .setMinLength(1)
        .setMaxLength(1);

      // Add inputs to action rows
      const titleRow = new ActionRowBuilder<TextInputBuilder>().addComponents(titleInput);
      const descriptionRow = new ActionRowBuilder<TextInputBuilder>().addComponents(descriptionInput);
      const intensityRow = new ActionRowBuilder<TextInputBuilder>().addComponents(intensityInput);

      modal.addComponents(titleRow, descriptionRow, intensityRow);

      await interaction.showModal(modal);
      return;
    }

    // /mystats command
    if (commandName === 'stats') {
      const stats = await statsService.getUserStats(user.id);

      if (!stats) {
        await interaction.reply({
          content:
            'No stats yet! Complete your first session with /start and /end.',
          ephemeral: true,
        });
        return;
      }

      const now = new Date();

      // Calculate stats for each timeframe
      const today = getStartOfDayPacific();
      const todaySessions = await sessionService.getCompletedSessions(
        user.id,
        Timestamp.fromDate(today)
      );

      const weekStart = getStartOfWeekPacific();
      const weeklySessions = await sessionService.getCompletedSessions(
        user.id,
        Timestamp.fromDate(weekStart)
      );

      const monthStart = getStartOfMonthPacific();
      const monthlySessions = await sessionService.getCompletedSessions(
        user.id,
        Timestamp.fromDate(monthStart)
      );

      const allSessions = await sessionService.getCompletedSessions(user.id);

      // Calculate durations in hours
      const dailyHours = todaySessions.reduce((sum, s) => sum + s.duration, 0) / 3600;
      const weeklyHours = weeklySessions.reduce((sum, s) => sum + s.duration, 0) / 3600;
      const monthlyHours = monthlySessions.reduce((sum, s) => sum + s.duration, 0) / 3600;
      const allTimeHours = allSessions.reduce((sum, s) => sum + s.duration, 0) / 3600;

      // Calculate average per day for current month (using Pacific Time)
      const pacificNow = new Date().toLocaleString('en-US', { timeZone: 'America/Los_Angeles' });
      const pacificDate = new Date(pacificNow);
      const monthName = ['January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'][pacificDate.getMonth()];
      const currentDay = pacificDate.getDate();
      const avgPerDay = currentDay > 0 ? (monthlyHours / currentDay) : 0;

      // Format hours with 1 decimal place
      const formatHours = (hours: number) => hours.toFixed(1) + 'h';

      // Create fire emojis based on streak length
      const getStreakEmojis = (streak: number): string => {
        if (streak >= 30) return 'üî•üî•üî•';
        if (streak >= 7) return 'üî•üî•';
        if (streak >= 3) return 'üî•';
        return '';
      };

      const currentStreakEmojis = getStreakEmojis(stats.currentStreak);
      const longestStreakEmojis = getStreakEmojis(stats.longestStreak);

      // XP & Level info
      const currentXp = stats.xp || 0;
      const currentLevel = calculateLevel(currentXp);
      const xpToNext = xpToNextLevel(currentXp);
      const progress = levelProgress(currentXp);

      // Create progress bar (20 characters wide)
      const progressBarLength = 20;
      const filledLength = Math.floor((progress / 100) * progressBarLength);
      const progressBar = '‚ñà'.repeat(filledLength) + '‚ñë'.repeat(progressBarLength - filledLength);

      // Get user achievements
      const userAchievements = await achievementService.getUserAchievements(user.id);

      // Achievement display (show first 10, or "X more" if > 10)
      let achievementDisplay = '';
      if (userAchievements.length > 0) {
        const displayAchievements = userAchievements.slice(0, 10);
        achievementDisplay = displayAchievements.map(b => b.emoji).join(' ');
        if (userAchievements.length > 10) {
          achievementDisplay += ` +${userAchievements.length - 10} more`;
        }
      } else {
        achievementDisplay = '*No achievements yet - complete sessions to earn achievements!*';
      }

      // Create embed with separate fields for better formatting
      const avatarUrl = user.displayAvatarURL({ size: 128 });

      const embed = new EmbedBuilder()
        .setColor(0x0080FF)
        .setTitle('üìä Personal Study Statistics')
        .setDescription(
          `**Level ${currentLevel}** ${progressBar} ${progress.toFixed(0)}%\n` +
          `${currentXp.toLocaleString()} XP ‚Ä¢ ${xpToNext.toLocaleString()} XP to Level ${currentLevel + 1}`
        )
        .addFields(
          { name: 'üìÖ Timeframe', value: '**Daily**\n**Weekly**\n**Monthly**\n**All-time**', inline: true },
          { name: '‚è±Ô∏è Hours', value: `${formatHours(dailyHours)}\n${formatHours(weeklyHours)}\n${formatHours(monthlyHours)}\n${formatHours(allTimeHours)}`, inline: true },
          { name: '\u200B', value: '\u200B', inline: true },
          { name: 'üìö Total Sessions', value: `**${stats.totalSessions}**`, inline: true },
          { name: 'üìà Hours/day (' + monthName + ')', value: `**${avgPerDay.toFixed(1)} h**`, inline: true },
          { name: '\u200B', value: '\u200B', inline: true },
          { name: 'üî• Current Streak', value: `**${stats.currentStreak}** days ${currentStreakEmojis}`, inline: true },
          { name: 'üí™ Longest Streak', value: `**${stats.longestStreak}** days ${longestStreakEmojis}`, inline: true },
          { name: '\u200B', value: '\u200B', inline: true },
          { name: `üèÜ Achievements (${userAchievements.length})`, value: achievementDisplay, inline: false }
        )
        .setFooter({
          text: user.username,
          iconURL: avatarUrl
        });

      await interaction.reply({
        embeds: [embed],
        ephemeral: false,
      });
      return;
    }

    // /achievements command
    if (commandName === 'testlevelup') {
      // Preview level-up and session post embeds
      const config = await getServerConfig(interaction.guildId!);

      if (!config || !config.feedChannelId) {
        await interaction.reply({
          content: '‚ùå No feed channel configured! Use `/setup-feed` first.',
          ephemeral: true,
        });
        return;
      }

      await interaction.deferReply({ ephemeral: true });

      try {
        const channel = await client.channels.fetch(config.feedChannelId);

        if (!channel || !channel.isTextBased()) {
          await interaction.editReply('‚ùå Feed channel not found or not text-based');
          return;
        }

        const textChannel = channel as TextChannel;
        const avatarUrl = user.displayAvatarURL({ size: 128 });

        // 1. Post example session completion embed
        const sessionEmbed = new EmbedBuilder()
          .setColor(0x0080FF) // Electric blue
          .setAuthor({
            name: `${user.username} üéØ`,
            iconURL: avatarUrl
          })
          .setTitle('Deep work on React components')
          .setDescription('Built the new dashboard UI with real-time updates and fixed several performance issues')
          .addFields(
            { name: 'Activity', value: 'Frontend Development', inline: true },
            { name: 'Duration', value: '2h 45m', inline: true },
            { name: '', value: '', inline: false },
            { name: 'XP Earned', value: '+275 XP', inline: true },
            { name: 'Level', value: 'Level 8 ‚Üí 9', inline: true }
          )
          .setFooter({ text: `Session completed ‚Ä¢ ${new Date().toLocaleDateString()}` });

        const sessionMessage = await textChannel.send({
          embeds: [sessionEmbed]
        });

        await sessionMessage.react('‚ù§Ô∏è').catch(() => {});

        // 2. Post example level-up embed (right after)
        const levelUpEmbed = new EmbedBuilder()
          .setColor(0x9B59B6) // Purple
          .setAuthor({
            name: `${user.username} üéâ`,
            iconURL: avatarUrl
          })
          .setDescription(`**@${user.username}** is now Level 9! üéâ`)
          .setFooter({ text: 'About 5 more hours needed to reach Level 10!' });

        const levelUpMessage = await textChannel.send({
          embeds: [levelUpEmbed]
        });

        await levelUpMessage.react('üéâ').catch(() => {});
        await levelUpMessage.react('‚ú®').catch(() => {});

        await interaction.editReply({
          content: `‚úÖ Test embeds posted to <#${config.feedChannelId}>!\n\n**Posted:**\n1. Session completion embed (blue)\n2. Level-up celebration embed (purple)`
        });
      } catch (error) {
        console.error('Error posting test embeds:', error);
        await interaction.editReply('‚ùå Failed to post test embeds. Check bot permissions in the feed channel.');
      }
      return;
    }

    if (commandName === 'testachievements') {
      // Preview achievement unlock embed
      const config = await getServerConfig(interaction.guildId!);

      if (!config || !config.feedChannelId) {
        await interaction.reply({
          content: '‚ùå No feed channel configured! Use `/setup-feed` first.',
          ephemeral: true,
        });
        return;
      }

      await interaction.deferReply({ ephemeral: true });

      try {
        const channel = await client.channels.fetch(config.feedChannelId);

        if (!channel || !channel.isTextBased()) {
          await interaction.editReply('‚ùå Feed channel not found or not text-based');
          return;
        }

        const textChannel = channel as TextChannel;
        const avatarUrl = user.displayAvatarURL({ size: 128 });

        // Example: User unlocked 3 achievements
        const exampleAchievements = [
          {
            emoji: 'üéØ',
            name: 'First Steps',
            description: 'Complete your first session',
            xpReward: 50
          },
          {
            emoji: 'üî•',
            name: 'Hot Streak',
            description: 'Maintain a 3-day streak',
            xpReward: 50
          },
          {
            emoji: 'üíØ',
            name: 'Centurion',
            description: 'Study for 100 hours total',
            xpReward: 200
          }
        ];

        const achievementList = exampleAchievements.map(b => `${b.emoji} **${b.name}**\n${b.description}`).join('\n\n');
        const totalXP = exampleAchievements.reduce((sum, b) => sum + b.xpReward, 0);

        const message = `**@${user.username}** unlocked ${exampleAchievements.length} new achievements! üèÜ`;

        // Create achievement unlock embed
        const embed = new EmbedBuilder()
          .setColor(0xFFD700) // Gold
          .setAuthor({
            name: `${user.username} üèÜ`,
            iconURL: avatarUrl
          })
          .setDescription(`${message}\n\n${achievementList}`)
          .setFooter({ text: `+${totalXP} bonus XP earned` });

        const achievementMessage = await textChannel.send({
          embeds: [embed]
        });

        // React with confetti if bot has permission
        await achievementMessage.react('üéâ').catch(() => {});

        await interaction.editReply({
          content: `‚úÖ Test achievement embed posted to <#${config.feedChannelId}>!\n\n**Posted:**\n- Achievement unlock embed (gold) with 3 example achievements`
        });
      } catch (error) {
        console.error('Error posting test achievement embed:', error);
        await interaction.editReply('‚ùå Failed to post test embed. Check bot permissions in the feed channel.');
      }
      return;
    }

    if (commandName === 'achievements') {
      const stats = await statsService.getUserStats(user.id);

      if (!stats) {
        await interaction.reply({
          content: 'No stats yet! Complete sessions to unlock achievements.',
          ephemeral: true,
        });
        return;
      }

      const userAchievements = await achievementService.getUserAchievements(user.id);
      const allAchievements = getAllAchievements();

      // Get unlocked achievement IDs for quick lookup
      const unlockedIds = new Set(userAchievements.map(b => b.id));

      // Separate unlocked and locked achievements
      const unlockedAchievements = allAchievements.filter(b => unlockedIds.has(b.id)).sort((a, b) => a.order - b.order);
      const lockedAchievements = allAchievements.filter(b => !unlockedIds.has(b.id)).sort((a, b) => a.order - b.order);

      // Create achievement list (show unlocked by default)
      const achievementList = unlockedAchievements.length > 0
        ? unlockedAchievements.map(b => `${b.emoji} **${b.name}** - *${b.description}*`).join('\n')
        : '*No achievements unlocked yet. Keep studying to earn your first achievement!*';

      const avatarUrl = user.displayAvatarURL({ size: 128 });

      const embed = new EmbedBuilder()
        .setColor(0xFFD700) // Gold
        .setTitle(`üèÜ Your Achievements (${unlockedAchievements.length}/${allAchievements.length})`)
        .setDescription(achievementList)
        .setFooter({
          text: user.username,
          iconURL: avatarUrl
        });

      // Create dropdown menu
      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId(`achievement_filter:${user.id}`)
        .setPlaceholder('Filter achievements')
        .addOptions([
          {
            label: 'Unlocked',
            description: `View your ${unlockedAchievements.length} unlocked achievements`,
            value: 'unlocked',
            emoji: '‚úÖ',
            default: true,
          },
          {
            label: 'Locked',
            description: `View ${lockedAchievements.length} achievements you haven't earned yet`,
            value: 'locked',
            emoji: 'üîí',
          },
        ]);

      const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(selectMenu);

      await interaction.reply({
        embeds: [embed],
        components: [row],
        ephemeral: false,
      });
      return;
    }

    // /profile command - View user profile with comprehensive stats
    if (commandName === 'profile') {
      const targetUser = interaction.options.getUser('user') || user;
      const stats = await statsService.getUserStats(targetUser.id);

      if (!stats) {
        await interaction.reply({
          content: `${targetUser.id === user.id ? 'You haven\'t' : `${targetUser.username} hasn't`} completed any sessions yet!`,
          ephemeral: true,
        });
        return;
      }

      // Calculate XP and level
      const currentXp = stats.xp || 0;
      const currentLevel = calculateLevel(currentXp);
      const xpToNext = xpToNextLevel(currentXp);
      const progress = levelProgress(currentXp);

      // Build progress bar
      const progressBarLength = 20;
      const filledLength = Math.floor((progress / 100) * progressBarLength);
      const progressBar = '‚ñà'.repeat(filledLength) + '‚ñë'.repeat(progressBarLength - filledLength);

      // Get achievements
      const userAchievements = await achievementService.getUserAchievements(targetUser.id);
      let achievementDisplay = '';
      if (userAchievements.length > 0) {
        const topAchievements = userAchievements.slice(0, 5);
        achievementDisplay = topAchievements.map(b => b.emoji).join(' ');
        if (userAchievements.length > 5) {
          achievementDisplay += ` +${userAchievements.length - 5} more`;
        }
      } else {
        achievementDisplay = '*No achievements yet*';
      }

      // Streak emojis
      const currentStreakEmojis = 'üî•'.repeat(Math.min(Math.floor(stats.currentStreak / 7), 5));
      const longestStreakEmojis = 'üî•'.repeat(Math.min(Math.floor(stats.longestStreak / 7), 5));

      const avatarUrl = targetUser.displayAvatarURL({ size: 256 });

      const embed = new EmbedBuilder()
        .setColor(0x0080FF)
        .setTitle(`${targetUser.username}'s Profile`)
        .setThumbnail(avatarUrl)
        .setDescription(
          `**Level ${currentLevel}** ${progressBar} ${progress.toFixed(0)}%\n` +
          `${currentXp.toLocaleString()} XP ‚Ä¢ ${xpToNext.toLocaleString()} XP to Level ${currentLevel + 1}`
        )
        .addFields(
          {
            name: 'üèÜ Achievements',
            value: `${userAchievements.length}/20 ‚Ä¢ ${achievementDisplay}`,
            inline: false
          },
          {
            name: 'üìä Statistics',
            value:
              `**Total Sessions:** ${stats.totalSessions}\n` +
              `**Total Hours:** ${(stats.totalDuration / 3600).toFixed(1)}h\n` +
              `**Longest Session:** ${stats.longestSessionDuration ? formatDuration(stats.longestSessionDuration) : 'N/A'}`,
            inline: true
          },
          {
            name: 'üî• Streaks',
            value:
              `**Current:** ${stats.currentStreak} days ${currentStreakEmojis}\n` +
              `**Longest:** ${stats.longestStreak} days ${longestStreakEmojis}`,
            inline: true
          }
        )
        .setFooter({
          text: `Member since their first session`,
          iconURL: avatarUrl
        })
        .setTimestamp(stats.firstSessionAt.toDate());

      await interaction.reply({
        embeds: [embed],
        ephemeral: false,
      });
      return;
    }

    // /compare command - Compare two users' stats
    if (commandName === 'compare') {
      const targetUser = interaction.options.getUser('user', true);

      // Prevent comparing with yourself
      if (targetUser.id === user.id) {
        await interaction.reply({
          content: '‚ùå You cannot compare with yourself! Try `/stats` to view your own stats.',
          ephemeral: true,
        });
        return;
      }

      // Prevent comparing with bots
      if (targetUser.bot) {
        await interaction.reply({
          content: '‚ùå Cannot compare with bots!',
          ephemeral: true,
        });
        return;
      }

      // Get both users' stats
      const [yourStats, theirStats] = await Promise.all([
        statsService.getUserStats(user.id),
        statsService.getUserStats(targetUser.id),
      ]);

      if (!yourStats) {
        await interaction.reply({
          content: 'You haven\'t completed any sessions yet! Complete your first session with `/start` and `/end`.',
          ephemeral: true,
        });
        return;
      }

      if (!theirStats) {
        await interaction.reply({
          content: `${targetUser.username} hasn't completed any sessions yet!`,
          ephemeral: true,
        });
        return;
      }

      // Calculate stats for both users
      const yourXP = yourStats.xp || 0;
      const theirXP = theirStats.xp || 0;
      const yourLevel = calculateLevel(yourXP);
      const theirLevel = calculateLevel(theirXP);
      const yourHours = yourStats.totalDuration / 3600;
      const theirHours = theirStats.totalDuration / 3600;

      // Get achievements for both users
      const [yourAchievements, theirAchievements] = await Promise.all([
        achievementService.getUserAchievements(user.id),
        achievementService.getUserAchievements(targetUser.id),
      ]);

      const avatarUrl1 = user.displayAvatarURL({ size: 128 });
      const avatarUrl2 = targetUser.displayAvatarURL({ size: 128 });

      // Determine who's ahead overall
      const xpDiff = Math.abs(yourXP - theirXP);
      let headerText = '';
      if (yourXP > theirXP) {
        headerText = `+${xpDiff.toLocaleString()} XP ahead`;
      } else if (theirXP > yourXP) {
        headerText = `${xpDiff.toLocaleString()} XP behind`;
      } else {
        headerText = 'Tied';
      }

      const embed = new EmbedBuilder()
        .setColor(0x5865F2)
        .setTitle(`${user.username} vs ${targetUser.username}`)
        .setThumbnail(avatarUrl1)
        .setDescription(headerText)
        .addFields(
          {
            name: user.username,
            value:
              `Level **${yourLevel}**\n` +
              `**${yourXP.toLocaleString()}** XP\n` +
              `**${yourHours.toFixed(1)}h** logged\n` +
              `**${yourStats.totalSessions}** sessions\n` +
              `**${yourStats.currentStreak}d** streak\n` +
              `**${yourAchievements.length}** achievements`,
            inline: true
          },
          {
            name: targetUser.username,
            value:
              `Level **${theirLevel}**\n` +
              `**${theirXP.toLocaleString()}** XP\n` +
              `**${theirHours.toFixed(1)}h** logged\n` +
              `**${theirStats.totalSessions}** sessions\n` +
              `**${theirStats.currentStreak}d** streak\n` +
              `**${theirAchievements.length}** achievements`,
            inline: true
          }
        )
        .setImage(avatarUrl2);

      await interaction.reply({
        embeds: [embed],
        ephemeral: false,
      });
      return;
    }

    // /live command - Show who's currently studying in this server
    if (commandName === 'live') {
      await interaction.deferReply({ ephemeral: false });
      const activeSessions = await sessionService.getActiveSessionsByServer(guildId!);
      const totalLive = activeSessions.length;

      if (totalLive === 0) {
        await interaction.editReply({
          content: 'üëª Nobody is studying right now. Be the first! Use /start to begin.',
        });
        return;
      }

      // Sort by start time (earliest first)
      activeSessions.sort((a, b) => a.startTime.toMillis() - b.startTime.toMillis());

      // Limit to 10 users max to avoid spam
      const displaySessions = activeSessions.slice(0, 10);

      // Build description with list of active users
      let description = '';

      for (const session of displaySessions) {
        const elapsed = calculateDuration(
          session.startTime,
          session.pausedDuration,
          session.isPaused ? session.pausedAt : undefined
        );
        const elapsedStr = formatDuration(elapsed);
        const statusEmoji = session.isPaused ? '‚è∏Ô∏è' : 'üü¢';

        // Format: üü¢ **username** working on **activity** for 1h 23m
        description += `${statusEmoji} **${session.username}** working on **${session.activity}** for ${elapsedStr}\n`;
      }

      // Create single embed with list
      const embed = new EmbedBuilder()
        .setColor(0x00FF00) // Green for live
        .setTitle(`üü¢ ${totalLive} ${totalLive === 1 ? 'person is' : 'people are'} studying right now`)
        .setDescription(description.trim())
        .setTimestamp();

      if (totalLive > 10) {
        embed.setFooter({ text: 'Showing first 10 users' });
      }

      await interaction.editReply({
        embeds: [embed],
      });
      return;
    }

    // /leaderboard command - Interactive leaderboard with timeframe selector
    if (commandName === 'leaderboard') {
      // Defer IMMEDIATELY before any logging to prevent timeout
      await interaction.deferReply({ ephemeral: false });
      console.log(`[LEADERBOARD] Command started for user ${user.username} (${user.id})`);

      // Get data for all timeframes
      const today = getStartOfDayPacific();
      const weekStart = getStartOfWeekPacific();
      const monthStart = getStartOfMonthPacific();

      console.log(`[LEADERBOARD] Timeframes - Today: ${today.toISOString()}, Week: ${weekStart.toISOString()}, Month: ${monthStart.toISOString()}`);

      const [dailyAll, weeklyAll, monthlyAll] = await Promise.all([
        sessionService.getTopUsers(Timestamp.fromDate(today), 20, guildId!),
        sessionService.getTopUsers(Timestamp.fromDate(weekStart), 20, guildId!),
        sessionService.getTopUsers(Timestamp.fromDate(monthStart), 20, guildId!),
      ]);

      console.log(`[LEADERBOARD] Fetched users - Daily: ${dailyAll.length}, Weekly: ${weeklyAll.length}, Monthly: ${monthlyAll.length}`);

      // Log detailed user data
      console.log(`[LEADERBOARD] Daily top users:`, dailyAll.map(u => ({
        username: u.username,
        userId: u.userId,
        totalDuration: u.totalDuration,
        hours: (u.totalDuration / 3600).toFixed(2),
        sessionCount: u.sessionCount
      })));

      console.log(`[LEADERBOARD] Weekly top users:`, weeklyAll.map(u => ({
        username: u.username,
        userId: u.userId,
        totalDuration: u.totalDuration,
        hours: (u.totalDuration / 3600).toFixed(2),
        sessionCount: u.sessionCount
      })));

      console.log(`[LEADERBOARD] Monthly top users:`, monthlyAll.map(u => ({
        username: u.username,
        userId: u.userId,
        totalDuration: u.totalDuration,
        hours: (u.totalDuration / 3600).toFixed(2),
        sessionCount: u.sessionCount
      })));

      // Find current user position
      const dailyUserPos = dailyAll.findIndex(u => u.userId === user.id);
      const weeklyUserPos = weeklyAll.findIndex(u => u.userId === user.id);
      const monthlyUserPos = monthlyAll.findIndex(u => u.userId === user.id);

      console.log(`[LEADERBOARD] User ${user.username} positions - Daily: ${dailyUserPos >= 0 ? dailyUserPos + 1 : 'N/A'}, Weekly: ${weeklyUserPos >= 0 ? weeklyUserPos + 1 : 'N/A'}, Monthly: ${monthlyUserPos >= 0 ? monthlyUserPos + 1 : 'N/A'}`);

      if (dailyUserPos >= 0) {
        const userData = dailyAll[dailyUserPos];
        console.log(`[LEADERBOARD] User ${user.username} daily data:`, {
          totalDuration: userData.totalDuration,
          hours: (userData.totalDuration / 3600).toFixed(2),
          sessionCount: userData.sessionCount
        });
      }

      // Helper to format top 3 + user position
      const formatLeaderboard = (allUsers: Array<{ userId: string; username: string; totalDuration: number }>, emoji: string, label: string) => {
        if (allUsers.length === 0) return `${emoji} **${label}**\nNo data yet`;

        const lines: string[] = [];
        const userPosition = allUsers.findIndex(u => u.userId === user.id);

        // Add top 3
        for (let i = 0; i < Math.min(3, allUsers.length); i++) {
          const u = allUsers[i];
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : 'ü•â';
          lines.push(`${medal} **${u.username}** - ${(u.totalDuration / 3600).toFixed(1)}h`);
        }

        // Add current user if not in top 3
        if (userPosition > 2) {
          const current = allUsers[userPosition];
          lines.push(`**${userPosition + 1}. ${current.username} - ${(current.totalDuration / 3600).toFixed(1)}h**`);
        }

        return `${emoji} **${label}**\n${lines.join('\n')}`;
      };

      const embed = new EmbedBuilder()
        .setColor(0xFFD700)
        .setTitle('üèÜ Your Leaderboard Position')
        .addFields(
          { name: '\u200B', value: formatLeaderboard(dailyAll, 'üìÖ', 'Daily'), inline: false },
          { name: '\u200B', value: formatLeaderboard(weeklyAll, 'üìä', 'Weekly'), inline: false },
          { name: '\u200B', value: formatLeaderboard(monthlyAll, 'üåü', 'Monthly'), inline: false }
        )
        .setFooter({ text: 'Use the dropdown below to view full leaderboards' });

      // Create select menu for switching views
      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('leaderboard_timeframe')
        .setPlaceholder('Select a timeframe to view')
        .addOptions([
          {
            label: 'Overview',
            description: 'Top 3 from each timeframe + your position',
            value: 'overview',
            emoji: 'üèÜ',
          },
          {
            label: 'Daily Leaderboard',
            description: 'Full top 10 daily rankings by hours',
            value: 'daily',
            emoji: 'üìÖ',
          },
          {
            label: 'Weekly Leaderboard',
            description: 'Full top 10 weekly rankings by hours',
            value: 'weekly',
            emoji: 'üìä',
          },
          {
            label: 'Monthly Leaderboard',
            description: 'Full top 10 monthly rankings by hours',
            value: 'monthly',
            emoji: 'üåü',
          },
          {
            label: 'XP Leaderboard',
            description: 'Top 10 by total XP and level',
            value: 'xp',
            emoji: '‚ö°',
          },
        ]);

      const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(selectMenu);

      console.log(`[LEADERBOARD] Sending response to user ${user.username}`);
      await interaction.editReply({ embeds: [embed], components: [row] });
      console.log(`[LEADERBOARD] Command completed successfully`);
      return;
    }

    // /manual command - Log a manual session
    if (commandName === 'manual') {
      // Create modal for manual session logging
      const modal = new ModalBuilder()
        .setCustomId('manualSessionModal')
        .setTitle('Log Manual Session');

      // Activity input
      const activityInput = new TextInputBuilder()
        .setCustomId('activity')
        .setLabel('Activity')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('e.g., Studying math, Writing essay')
        .setRequired(true)
        .setMaxLength(100);

      // Title input
      const titleInput = new TextInputBuilder()
        .setCustomId('title')
        .setLabel('Session Title')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('e.g., Finished chapter 5, Fixed login bug')
        .setRequired(true)
        .setMaxLength(100);

      // Description input
      const descriptionInput = new TextInputBuilder()
        .setCustomId('description')
        .setLabel('What did you accomplish?')
        .setStyle(TextInputStyle.Paragraph)
        .setPlaceholder('Share what you worked on and what you achieved...')
        .setRequired(true)
        .setMaxLength(1000);

      // Duration input (combined hours and minutes)
      const durationInput = new TextInputBuilder()
        .setCustomId('duration')
        .setLabel('Duration (format: "2h 30m" or "90m")')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('e.g., 1h 30m, 2h, 45m')
        .setRequired(true)
        .setMaxLength(20);

      // Intensity input (1-5 scale)
      const intensityInput = new TextInputBuilder()
        .setCustomId('intensity')
        .setLabel('Session Intensity (1-5)')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('1=Light, 2=Easy, 3=Normal, 4=Hard, 5=Max Effort')
        .setRequired(true)
        .setMinLength(1)
        .setMaxLength(1);

      // Add inputs to action rows
      const activityRow = new ActionRowBuilder<TextInputBuilder>().addComponents(activityInput);
      const titleRow = new ActionRowBuilder<TextInputBuilder>().addComponents(titleInput);
      const descriptionRow = new ActionRowBuilder<TextInputBuilder>().addComponents(descriptionInput);
      const durationRow = new ActionRowBuilder<TextInputBuilder>().addComponents(durationInput);
      const intensityRow = new ActionRowBuilder<TextInputBuilder>().addComponents(intensityInput);

      modal.addComponents(activityRow, titleRow, descriptionRow, durationRow, intensityRow);

      await interaction.showModal(modal);
      return;
    }

    // /setup-feed command
    if (commandName === 'setup-feed') {
      const channel = interaction.options.getChannel('channel', true);

      // Check if user has admin permission
      if (
        !interaction.memberPermissions?.has(PermissionFlagsBits.Administrator)
      ) {
        await interaction.reply({
          content: 'Only server administrators can set up the feed channel.',
          ephemeral: true,
        });
        return;
      }

      // Get existing config
      const existingConfig = await getServerConfig(guildId!);

      // Update config
      const config: ServerConfig = {
        ...existingConfig,
        feedChannelId: channel.id,
        setupAt: Timestamp.now(),
        setupBy: user.id,
      };

      await db
        .collection('discord-data')
        .doc('serverConfig')
        .collection('configs')
        .doc(guildId!)
        .set(config);

      await interaction.reply({
        content: `‚úÖ Feed channel set to <#${channel.id}>\n\nCompleted sessions will now be posted there automatically.`,
        ephemeral: true,
      });
      return;
    }

    // /setup-focus-room command
    if (commandName === 'setup-focus-room') {
      const channel = interaction.options.getChannel('channel', true);

      // Check if user has admin permission
      if (
        !interaction.memberPermissions?.has(PermissionFlagsBits.Administrator)
      ) {
        await interaction.reply({
          content: 'Only server administrators can configure focus rooms.',
          ephemeral: true,
        });
        return;
      }

      // Get existing config
      const existingConfig = await getServerConfig(guildId!);
      const currentFocusRooms = existingConfig?.focusRoomIds || [];

      // Check if already configured
      if (currentFocusRooms.includes(channel.id)) {
        await interaction.reply({
          content: `<#${channel.id}> is already configured as a focus room.`,
          ephemeral: true,
        });
        return;
      }

      // Add to focus rooms
      const updatedFocusRooms = [...currentFocusRooms, channel.id];

      const config: ServerConfig = {
        ...existingConfig,
        focusRoomIds: updatedFocusRooms,
        setupAt: Timestamp.now(),
        setupBy: user.id,
      };

      await db
        .collection('discord-data')
        .doc('serverConfig')
        .collection('configs')
        .doc(guildId!)
        .set(config);

      await interaction.reply({
        content: `‚úÖ Focus room enabled: <#${channel.id}>\n\nJoining this voice channel will now automatically start tracking your session!`,
        ephemeral: true,
      });
      return;
    }

    // /set-welcome-channel command
    if (commandName === 'set-welcome-channel') {
      const channel = interaction.options.getChannel('channel', true);

      // Check if user has admin permission
      if (
        !interaction.memberPermissions?.has(PermissionFlagsBits.Administrator)
      ) {
        await interaction.reply({
          content: 'Only server administrators can set the welcome channel.',
          ephemeral: true,
        });
        return;
      }

      // Get existing config
      const existingConfig = await getServerConfig(guildId!);

      // Update config
      const config: ServerConfig = {
        ...existingConfig,
        welcomeChannelId: channel.id,
        setupAt: Timestamp.now(),
        setupBy: user.id,
      };

      await db
        .collection('discord-data')
        .doc('serverConfig')
        .collection('configs')
        .doc(guildId!)
        .set(config);

      await interaction.reply({
        content: `‚úÖ Welcome channel set to <#${channel.id}>\n\nNew members will receive a welcome message in this channel when they join!`,
        ephemeral: true,
      });
      return;
    }

    // /setup-events-channel command
    if (commandName === 'setup-events-channel') {
      const channel = interaction.options.getChannel('channel', true);

      // Check if user has admin permission
      if (
        !interaction.memberPermissions?.has(PermissionFlagsBits.Administrator)
      ) {
        await interaction.reply({
          content: 'Only server administrators can set the events channel.',
          ephemeral: true,
        });
        return;
      }

      // Get existing config
      const existingConfig = await getServerConfig(guildId!);

      // Update config
      const config: ServerConfig = {
        ...existingConfig,
        eventsChannelId: channel.id,
        setupAt: Timestamp.now(),
        setupBy: user.id,
      };

      await db
        .collection('discord-data')
        .doc('serverConfig')
        .collection('configs')
        .doc(guildId!)
        .set(config);

      await interaction.reply({
        content: `‚úÖ Events channel set to <#${channel.id}>\n\nAll new study events will be posted in this channel!`,
        ephemeral: true,
      });
      return;
    }
  } catch (error) {
    console.error(`Error handling command ${commandName}:`, error);

    const errorMessage =
      'An error occurred while processing your command. Please try again.';

    try {
      if (interaction.replied || interaction.deferred) {
        await interaction.followUp({ content: errorMessage, ephemeral: true });
      } else {
        await interaction.reply({ content: errorMessage, ephemeral: true });
      }
    } catch (replyError) {
      // Interaction may have expired - just log the error and continue
      console.error('Could not send error message to user:', replyError);
    }
  }
});

// Handle voice state updates (VC joins/leaves)
client.on('voiceStateUpdate', async (oldState, newState) => {
  try {
    const userId = newState.member?.user.id;
    const guildId = newState.guild.id;

    console.log(`[VOICE STATE] User: ${newState.member?.user.username}, Old: ${oldState.channelId}, New: ${newState.channelId}`);

    if (!userId || !guildId) {
      console.log('[VOICE STATE] Missing userId or guildId');
      return;
    }

    // Get server config to check if this is a focus room
    const config = await getServerConfig(guildId);
    console.log(`[VOICE STATE] Config:`, config);

    if (!config || !config.focusRoomIds || config.focusRoomIds.length === 0) {
      console.log('[VOICE STATE] No focus rooms configured');
      return;
    }

    const oldChannelId = oldState.channelId;
    const newChannelId = newState.channelId;

    // User joined a VC
    console.log(`[VOICE STATE] Checking join: oldChannelId=${oldChannelId}, newChannelId=${newChannelId}, isFocusRoom=${config.focusRoomIds.includes(newChannelId || '')}`);

    if (!oldChannelId && newChannelId && config.focusRoomIds.includes(newChannelId)) {
      console.log('[VOICE STATE] User joined a focus room!');

      // Check if user has a pending session (left VC but hasn't ended)
      const existingSession = await sessionService.getActiveSession(userId);
      console.log('[VOICE STATE] Existing session:', existingSession);

      if (existingSession && existingSession.isVCSession && existingSession.pendingCompletion) {
        console.log('[VOICE STATE] Resuming existing session');
        // Resume existing session
        await sessionService.updateActiveSession(userId, {
          pendingCompletion: false,
          leftVCAt: null as any,
        });

        // Cancel auto-post timer
        cancelAutoPost(userId);

        console.log(`${newState.member?.user.username} resumed VC session`);
      } else if (!existingSession) {
        console.log('[VOICE STATE] Creating new VC session');
        // Create new VC session
        const username = newState.member?.user.username || 'Unknown';
        const avatarUrl = newState.member?.user.displayAvatarURL({ size: 128 }) || '';

        await sessionService.createActiveSession(
          userId,
          username,
          guildId,
          'VC Session'
        );

        // Mark as VC session
        await sessionService.updateActiveSession(userId, {
          isVCSession: true,
          vcChannelId: newChannelId,
        });

        // Post to feed
        console.log('[VOICE STATE] Posting to feed');
        await postVCSessionStartToFeed(
          guildId,
          username,
          userId,
          avatarUrl,
          newChannelId
        );

        console.log(`${username} started VC session in ${newChannelId}`);
      } else {
        console.log('[VOICE STATE] User already has a session (not VC or not pending)');
      }
    }

    // User left a VC (or switched channels)
    if (oldChannelId && config.focusRoomIds.includes(oldChannelId)) {
      const session = await sessionService.getActiveSession(userId);

      if (session && session.isVCSession && !session.pendingCompletion) {
        // If user switched to another focus room, don't mark as pending
        if (newChannelId && config.focusRoomIds.includes(newChannelId)) {
          // Update the VC channel ID
          await sessionService.updateActiveSession(userId, {
            vcChannelId: newChannelId,
          });
          return;
        }

        // Calculate current duration
        const duration = calculateDuration(
          session.startTime,
          session.pausedDuration,
          session.isPaused ? session.pausedAt : undefined
        );
        const durationStr = formatDuration(duration);

        // Mark as pending completion
        await sessionService.updateActiveSession(userId, {
          pendingCompletion: true,
          leftVCAt: Timestamp.now(),
        });

        // Schedule auto-post after 1 hour
        scheduleAutoPost(userId, guildId);

        // DM the user about leaving VC
        try {
          const user = await client.users.fetch(userId);
          await user.send(
            `You just focused in VC for **${durationStr}**. Type \`/end\` to post your session, or rejoin VC to continue!\n\n*Auto-posts in 10 minutes*`
          );
        } catch (error) {
          console.error('Error sending DM to user:', error);
          // Fallback: post in feed channel if DM fails (user has DMs disabled)
          if (config.feedChannelId) {
            try {
              const feedChannel = await client.channels.fetch(config.feedChannelId);
              if (feedChannel && feedChannel.isTextBased()) {
                const textChannel = feedChannel as TextChannel;
                await textChannel.send(
                  `<@${userId}> You just focused in VC for **${durationStr}**. Type \`/end\` to post your session, or rejoin VC to continue!\n\n*Auto-posts in 10 minutes*`
                );
              }
            } catch (fallbackError) {
              console.error('Error posting VC leave ping to feed:', fallbackError);
            }
          }
        }

        console.log(`${session.username} left VC, session pending completion`);
      }
    }
  } catch (error) {
    console.error('Error handling voice state update:', error);
  }
});

// Bot ready event
// Handle voice state updates (join/leave voice channels)
client.on('voiceStateUpdate', async (oldState, newState) => {
  const userId = newState.member?.user.id;
  if (!userId) return;

  const username = newState.member?.user.username || 'Unknown';
  const guildId = newState.guild.id;

  // User left a voice channel
  const leftChannel = oldState.channelId && !newState.channelId;

  // User joined a voice channel
  const joinedChannel = !oldState.channelId && newState.channelId;

  try {
    if (leftChannel) {
      console.log(`[VOICE] ${username} (${userId}) left voice channel in guild ${guildId}`);

      // Check if user has an active session
      const session = await sessionService.getActiveSession(userId);

      if (session && !session.isPaused) {
        console.log(`[VOICE] Auto-pausing session for ${username}`);

        // Pause the session
        await sessionService.updateActiveSession(userId, {
          isPaused: true,
          pausedAt: Timestamp.now(),
        });

        // Set 10-minute timer to auto-end the session
        const timer = setTimeout(async () => {
          console.log(`[VOICE] 10-minute timer expired for ${username}, auto-ending session`);

          try {
            // Check if session still exists and is paused
            const currentSession = await sessionService.getActiveSession(userId);

            if (currentSession && currentSession.isPaused) {
              // Calculate final duration
              const duration = calculateDuration(
                currentSession.startTime,
                currentSession.pausedDuration,
                currentSession.pausedAt
              );

              const endTime = Timestamp.now();

              // Delete active session
              await sessionService.deleteActiveSession(userId);

              // Create completed session with auto-generated title
              await sessionService.createCompletedSession({
                userId,
                username,
                serverId: currentSession.serverId,
                activity: currentSession.activity,
                title: `${currentSession.activity} session`,
                description: 'Auto-ended after 10 minutes of inactivity',
                duration,
                startTime: currentSession.startTime,
                endTime,
              });

              // Update stats and award XP
              const statsUpdate = await statsService.updateUserStats(
                userId,
                username,
                duration,
                currentSession.activity
              );

              // Check for new achievements
              const newAchievements = await achievementService.checkAndAwardAchievements(userId);

              console.log(`[VOICE] Auto-ended session for ${username} (${formatDuration(duration)})`);

              // Try to send DM to user with XP and achievement info
              try {
                const user = await client.users.fetch(userId);
                let xpMessage = '';
                if (statsUpdate.leveledUp) {
                  xpMessage = `\n\nüéâ **LEVEL UP!** You're now Level ${statsUpdate.newLevel}!\n‚ú® +${statsUpdate.xpGained} XP earned!`;
                } else {
                  xpMessage = `\n‚ú® +${statsUpdate.xpGained} XP earned!`;
                }

                let achievementMessage = '';
                if (newAchievements.length > 0) {
                  const achievementDetails = newAchievements.map(id => getAchievement(id)).filter(b => b);
                  const achievementList = achievementDetails.map(b => `${b!.emoji} **${b!.name}**`).join(', ');
                  achievementMessage = `\nüèÜ **NEW ACHIEVEMENT${newAchievements.length > 1 ? 'S' : ''}!** ${achievementList}`;
                }

                await user.send(`‚è∞ Your session was automatically ended after 10 minutes of inactivity.\n\n**Activity:** ${currentSession.activity}\n**Duration:** ${formatDuration(duration)}${xpMessage}${achievementMessage}\n\nYour session has been saved!`);
              } catch (dmError) {
                console.log(`[VOICE] Could not send DM to ${username}`);
              }
            }
          } catch (error) {
            console.error(`[VOICE] Error auto-ending session for ${username}:`, error);
          } finally {
            // Clean up timer from map
            autoEndTimers.delete(userId);
          }
        }, 10 * 60 * 1000); // 10 minutes

        // Store timer reference
        autoEndTimers.set(userId, timer);
        console.log(`[VOICE] Set 10-minute auto-end timer for ${username}`);
      }
    } else if (joinedChannel) {
      console.log(`[VOICE] ${username} (${userId}) joined voice channel in guild ${guildId}`);

      // Check if user has a paused session
      const session = await sessionService.getActiveSession(userId);

      if (session && session.isPaused) {
        console.log(`[VOICE] Auto-resuming session for ${username}`);

        // Clear auto-end timer if it exists
        const timer = autoEndTimers.get(userId);
        if (timer) {
          clearTimeout(timer);
          autoEndTimers.delete(userId);
          console.log(`[VOICE] Cancelled auto-end timer for ${username}`);
        }

        // Calculate time spent paused
        const pausedDuration = session.pausedAt
          ? session.pausedDuration + (Timestamp.now().toMillis() - session.pausedAt.toMillis())
          : session.pausedDuration;

        // Resume the session
        await sessionService.updateActiveSession(userId, {
          isPaused: false,
          pausedAt: undefined,
          pausedDuration,
        });

        console.log(`[VOICE] Resumed session for ${username}`);
      }
    }
  } catch (error) {
    console.error(`[VOICE] Error handling voice state update for ${username}:`, error);
  }
});

client.once('clientReady', () => {
  console.log(`‚úÖ Bot is online as ${client.user?.tag}`);
});

// Handle new member joins
client.on('guildMemberAdd', async (member) => {
  try {
    const config = await getServerConfig(member.guild.id);

    if (!config || !config.welcomeChannelId) {
      // No welcome channel configured - skip
      return;
    }

    // Send DM to new member
    try {
      await member.send(
        `Welcome to **${member.guild.name}**! üëã\n\n` +
        `This server wants to make productivity social. Start tracking your study sessions with \`/start {activity}\` and see your progress on the leaderboard!\n\n` +
        `**Quick commands:**\n` +
        `‚Ä¢ \`/start {activity}\` - Begin a session\n` +
        `‚Ä¢ \`/end\` - Finish your session\n` +
        `‚Ä¢ \`/stats\` - View your statistics\n` +
        `‚Ä¢ \`/help\` - See all commands`
      );
    } catch (dmError) {
      console.error(`Could not send DM to ${member.user.tag}:`, dmError);
      // If DM fails (user has DMs disabled), post in welcome channel as fallback
      try {
        const channel = await client.channels.fetch(config.welcomeChannelId);
        if (channel && channel.isTextBased()) {
          const textChannel = channel as TextChannel;
          await textChannel.send(
            `Welcome <@${member.id}>! üëã\n\n` +
            `This server wants to make productivity social. Start tracking your study sessions with \`/start {activity}\` and see your progress on the leaderboard!\n\n` +
            `**Quick commands:**\n` +
            `‚Ä¢ \`/start {activity}\` - Begin a session\n` +
            `‚Ä¢ \`/end\` - Finish your session\n` +
            `‚Ä¢ \`/stats\` - View your statistics\n` +
            `‚Ä¢ \`/help\` - See all commands`
          );
        }
      } catch (channelError) {
        console.error('Error posting to welcome channel as fallback:', channelError);
      }
    }
  } catch (error) {
    console.error('Error in guildMemberAdd handler:', error);
  }
});

// Start bot
async function start() {
  await registerCommands();
  await client.login(process.env.DISCORD_BOT_TOKEN);
}

start().catch(console.error);
